{"version":3,"sources":["strophe-1.2.8.js"],"names":["callback","root","factory","define","amd","Base64","this","keyStr","encode","input","chr1","chr2","chr3","enc1","enc2","enc3","enc4","output","i","charCodeAt","isNaN","charAt","length","decode","replace","indexOf","String","fromCharCode","SHA1","core_sha1","x","len","j","t","olda","oldb","oldc","oldd","olde","w","Array","a","b","c","d","e","rol","safe_add","sha1_ft","sha1_kt","core_hmac_sha1","key","data","bkey","str2binb","ipad","opad","hash","concat","y","lsw","num","cnt","str","bin","binb2str","binb2b64","binarray","triplet","tab","b64_hmac_sha1","b64_sha1","s","str_hmac_sha1","str_sha1","MD5","bit_rol","str2binl","binl2str","binl2hex","hex_tab","md5_cmn","q","md5_ff","md5_gg","md5_hh","md5_ii","core_md5","hexdigest","stropheUtils","utf16to8","out","addCookies","cookies","cookieName","cookieObj","isObj","cookieValue","expires","domain","path","escape","unescape","value","document","cookie","Function","prototype","bind","obj","func","_slice","slice","_concat","_args","call","arguments","apply","isArray","arg","Object","toString","elt","from","Number","Math","ceil","floor","o","window","Strophe","$build","$iq","$msg","$pres","utils","name","attrs","Builder","VERSION","NS","HTTPBIND","BOSH","CLIENT","AUTH","ROSTER","PROFILE","DISCO_INFO","DISCO_ITEMS","MUC","SASL","STREAM","FRAMING","BIND","SESSION","STANZAS","XHTML_IM","XHTML","tags","attributes","blockquote","br","cite","em","img","li","ol","p","span","strong","ul","body","css","validTag","tag","validAttribute","attribute","validCSS","style","Status","ERROR","CONNECTING","CONNFAIL","AUTHENTICATING","AUTHFAIL","CONNECTED","DISCONNECTED","DISCONNECTING","ATTACHED","REDIRECT","CONNTIMEOUT","LogLevel","DEBUG","INFO","WARN","FATAL","ElementType","NORMAL","TEXT","CDATA","FRAGMENT","TIMEOUT","SECONDARY_TIMEOUT","addNamespace","forEachChild","elem","elemName","childNode","childNodes","nodeType","isTagEqual","el","tagName","_xmlGenerator","_makeGenerator","doc","undefined","implementation","createDocument","documentMode","_getIEXmlDom","appendChild","createElement","xmlGenerator","docStrings","ActiveXObject","xmlElement","k","node","xmlTextNode","attr","setAttribute","hasOwnProperty","xmlescape","text","xmlunescape","createTextNode","xmlHtmlNode","html","DOMParser","parseFromString","async","loadXML","getText","nodeValue","copyElement","nodeName","createHtml","cssAttrs","cssName","cssValue","toLowerCase","getAttribute","cssText","split","push","join","createDocumentFragment","escapeNode","unescapeNode","getNodeFromJid","jid","getDomainFromJid","bare","getBareJidFromJid","parts","splice","getResourceFromJid","log","level","msg","debug","info","warn","error","fatal","serialize","result","tree","child","_requestId","_connectionPlugins","addConnectionPlugin","ptype","xmlns","nodeTree","up","parentNode","moreattrs","removeAttribute","cnode","impNode","xmlGen","importNode","newElem","h","fragment","innerHTML","xhtml","Handler","handler","ns","type","id","options","matchBare","user","isMatch","nsMatch","that","elem_type","run","sourceURL","line","message","fileName","console","trace","lineNumber","stack","TimedHandler","period","lastCalled","Date","getTime","reset","Connection","service","proto","protocol","_proto","Websocket","Bosh","features","_sasl_data","do_session","do_bind","timedHandlers","handlers","removeTimeds","removeHandlers","addTimeds","addHandlers","_authentication","_idleTimeout","_disconnectTimeout","authenticated","connected","disconnecting","do_authentication","paused","restored","_data","_uniqueId","_sasl_success_handler","_sasl_failure_handler","_sasl_challenge_handler","maxRetries","setTimeout","_onIdle","F","init","_reset","_requests","pause","setJid","authzid","authcid","getJid","resume","getUniqueId","suffix","uuid","r","random","connect","pass","wait","hold","route","servtype","connect_callback","_changeConnectStatus","_connect","attach","sid","rid","wind","_attach","restore","_sessionCachingSupported","_restore","JSON","sessionStorage","setItem","removeItem","xmlInput","xmlOutput","rawInput","rawOutput","nextValidRid","send","_queueData","_send","flush","clearTimeout","sendIQ","errback","timeout","timeoutHandler","expectedFrom","fulljid","addHandler","stanza","deleteTimedHandler","acceptable","iqtype","addTimedHandler","deleteHandler","element","_sendRestart","thand","handRef","hand","disconnect","reason","pres","_addSysTimedHandler","_onDisconnectTimeout","_disconnect","_abortAllRequests","status","condition","plugin","statusChanged","err","_doDisconnect","_dataRecv","req","raw","WebIM","config","isDebug","stringify","_reqToData","strip","pop","_emptyQueue","cond","conflict","getElementsByTagName","newList","mechanisms","_connect_cb","_callback","bodyWrap","sasl_scram_sha1","sasl_plain","sasl_digest_md5","sasl_anonymous","legacy_auth","hasFeatures","getElementsByTagNameNS","mech","matched","_no_auth_received","authenticate","higher","priority","swap","mechanism_found","test","_addSysHandler","_sasl_success_cb","_sasl_failure_cb","_sasl_challenge_cb","_sasl_mechanism","onStart","request_auth_exchange","mechanism","isClientFirst","response","onChallenge","_auth1_cb","to","challenge","iq","_auth2_cb","serverSignature","success","attribMatch","matches","match","onSuccess","streamfeature_handlers","wrapper","_sasl_auth1_cb","_sasl_bind_cb","resource","jidNode","_sasl_session_cb","onFailure","since","now","SASLMechanism","connection","_connection","Error","SASLAnonymous","SASLPlain","auth_str","SASLSHA1","test_cnonce","cnonce","nonce","salt","iter","Hi","U","U_old","clientKey","serverKey","clientSignature","responseText","authMessage","substr","SASLMD5","_quote","realm","host","digest_uri","cred","A1","A2","SASLOAuthBearer","SASLExternal","core","Request","sends","xmlData","origFunc","date","NaN","abort","dead","age","timeDead","xhr","_newXHR","getResponse","responseXML","documentElement","XMLHttpRequest","overrideMimeType","onreadystatechange","_conn","errors","_buildBody","keepalive","_cacheSession","xml:lang","content","ver","xmpp:version","xmlns:xmpp","_onRequestStateChange","_throttledRequestHandler","session","parse","getItem","typ","parseInt","_sendTerminate","_hitError","reqStatus","xmpp:restart","time_elapsed","readyState","reqIs0","reqIs1","_removeRequest","_restartRequest","_processRequest","self","primaryTimeout","secondaryTimeout","requestCompletedWithServerError","contentType","open","sync","setRequestHeader","withCredentials","e2","sendFunc","customHeaders","headers","header","XDomainRequest","backoff","min","pow","abs","new_service","location","pathname","_buildStream","version","_check_streamerror","connectstatus","textContent","errorString","_closeSocket","socket","WebSocket","onopen","_onOpen","onerror","_onError","onclose","_onClose","onmessage","_connect_cb_wrapper","_handleStreamStart","streamStart","see_uri","string","_streamWrap","_onMessage","CLOSED","close","closeString","rawStanza","ts","search","firstChild","start","startString","n_callback","requirejs","require","build"],"mappings":"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","file":"strophe-1.2.8.min.js","sourcesContent":["/** File: strophe.js\n *  A JavaScript library for XMPP BOSH/XMPP over Websocket.\n *\n *  This is the JavaScript version of the Strophe library.  Since JavaScript\n *  had no facilities for persistent TCP connections, this library uses\n *  Bidirectional-streams Over Synchronous HTTP (BOSH) to emulate\n *  a persistent, stateful, two-way connection to an XMPP server.  More\n *  information on BOSH can be found in XEP 124.\n *\n *  This version of Strophe also works with WebSockets.\n *  For more information on XMPP-over WebSocket see this RFC:\n *  http://tools.ietf.org/html/rfc7395\n */\n\n/* All of the Strophe globals are defined in this special function below so\n * that references to the globals become closures.  This will ensure that\n * on page reload, these references will still be available to callbacks\n * that are still executing.\n */\n\n/* jshint ignore:start */\n(function (callback) {\n    /* jshint ignore:end */\n\n// This code was written by Tyler Akins and has been placed in the\n// public domain.  It would be nice if you left this header intact.\n// Base64 code from Tyler Akins -- http://rumkin.com\n\n    (function (root, factory) {\n        if (typeof define === 'function' && define.amd) {\n            define('strophe-base64', function () {\n                return factory();\n            });\n        } else {\n            // Browser globals\n            root.Base64 = factory();\n        }\n    }(this, function () {\n        var keyStr = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\";\n\n        var obj = {\n            /**\n             * Encodes a string in base64\n             * @param {String} input The string to encode in base64.\n             */\n            encode: function (input) {\n                var output = \"\";\n                var chr1, chr2, chr3;\n                var enc1, enc2, enc3, enc4;\n                var i = 0;\n\n                do {\n                    chr1 = input.charCodeAt(i++);\n                    chr2 = input.charCodeAt(i++);\n                    chr3 = input.charCodeAt(i++);\n\n                    enc1 = chr1 >> 2;\n                    enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);\n                    enc3 = ((chr2 & 15) << 2) | (chr3 >> 6);\n                    enc4 = chr3 & 63;\n\n                    if (isNaN(chr2)) {\n                        enc2 = ((chr1 & 3) << 4);\n                        enc3 = enc4 = 64;\n                    } else if (isNaN(chr3)) {\n                        enc4 = 64;\n                    }\n\n                    output = output + keyStr.charAt(enc1) + keyStr.charAt(enc2) +\n                        keyStr.charAt(enc3) + keyStr.charAt(enc4);\n                } while (i < input.length);\n\n                return output;\n            },\n\n            /**\n             * Decodes a base64 string.\n             * @param {String} input The string to decode.\n             */\n            decode: function (input) {\n                var output = \"\";\n                var chr1, chr2, chr3;\n                var enc1, enc2, enc3, enc4;\n                var i = 0;\n\n                // remove all characters that are not A-Z, a-z, 0-9, +, /, or =\n                input = input.replace(/[^A-Za-z0-9\\+\\/\\=]/g, \"\");\n\n                do {\n                    enc1 = keyStr.indexOf(input.charAt(i++));\n                    enc2 = keyStr.indexOf(input.charAt(i++));\n                    enc3 = keyStr.indexOf(input.charAt(i++));\n                    enc4 = keyStr.indexOf(input.charAt(i++));\n\n                    chr1 = (enc1 << 2) | (enc2 >> 4);\n                    chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);\n                    chr3 = ((enc3 & 3) << 6) | enc4;\n\n                    output = output + String.fromCharCode(chr1);\n\n                    if (enc3 != 64) {\n                        output = output + String.fromCharCode(chr2);\n                    }\n                    if (enc4 != 64) {\n                        output = output + String.fromCharCode(chr3);\n                    }\n                } while (i < input.length);\n\n                return output;\n            }\n        };\n        return obj;\n    }));\n\n    /*\n     * A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined\n     * in FIPS PUB 180-1\n     * Version 2.1a Copyright Paul Johnston 2000 - 2002.\n     * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet\n     * Distributed under the BSD License\n     * See http://pajhome.org.uk/crypt/md5 for details.\n     */\n\n    /* jshint undef: true, unused: true:, noarg: true, latedef: true */\n    /* global define */\n\n    /* Some functions and variables have been stripped for use with Strophe */\n\n    (function (root, factory) {\n        if (typeof define === 'function' && define.amd) {\n            define('strophe-sha1', function () {\n                return factory();\n            });\n        } else {\n            // Browser globals\n            root.SHA1 = factory();\n        }\n    }(this, function () {\n\n        /*\n         * Calculate the SHA-1 of an array of big-endian words, and a bit length\n         */\n        function core_sha1(x, len) {\n            /* append padding */\n            x[len >> 5] |= 0x80 << (24 - len % 32);\n            x[((len + 64 >> 9) << 4) + 15] = len;\n\n            var w = new Array(80);\n            var a = 1732584193;\n            var b = -271733879;\n            var c = -1732584194;\n            var d = 271733878;\n            var e = -1009589776;\n\n            var i, j, t, olda, oldb, oldc, oldd, olde;\n            for (i = 0; i < x.length; i += 16) {\n                olda = a;\n                oldb = b;\n                oldc = c;\n                oldd = d;\n                olde = e;\n\n                for (j = 0; j < 80; j++) {\n                    if (j < 16) {\n                        w[j] = x[i + j];\n                    }\n                    else {\n                        w[j] = rol(w[j - 3] ^ w[j - 8] ^ w[j - 14] ^ w[j - 16], 1);\n                    }\n                    t = safe_add(safe_add(rol(a, 5), sha1_ft(j, b, c, d)),\n                        safe_add(safe_add(e, w[j]), sha1_kt(j)));\n                    e = d;\n                    d = c;\n                    c = rol(b, 30);\n                    b = a;\n                    a = t;\n                }\n\n                a = safe_add(a, olda);\n                b = safe_add(b, oldb);\n                c = safe_add(c, oldc);\n                d = safe_add(d, oldd);\n                e = safe_add(e, olde);\n            }\n            return [a, b, c, d, e];\n        }\n\n        /*\n         * Perform the appropriate triplet combination function for the current\n         * iteration\n         */\n        function sha1_ft(t, b, c, d) {\n            if (t < 20) {\n                return (b & c) | ((~b) & d);\n            }\n            if (t < 40) {\n                return b ^ c ^ d;\n            }\n            if (t < 60) {\n                return (b & c) | (b & d) | (c & d);\n            }\n            return b ^ c ^ d;\n        }\n\n        /*\n         * Determine the appropriate additive constant for the current iteration\n         */\n        function sha1_kt(t) {\n            return (t < 20) ? 1518500249 : (t < 40) ? 1859775393 :\n                (t < 60) ? -1894007588 : -899497514;\n        }\n\n        /*\n         * Calculate the HMAC-SHA1 of a key and some data\n         */\n        function core_hmac_sha1(key, data) {\n            var bkey = str2binb(key);\n            if (bkey.length > 16) {\n                bkey = core_sha1(bkey, key.length * 8);\n            }\n\n            var ipad = new Array(16), opad = new Array(16);\n            for (var i = 0; i < 16; i++) {\n                ipad[i] = bkey[i] ^ 0x36363636;\n                opad[i] = bkey[i] ^ 0x5C5C5C5C;\n            }\n\n            var hash = core_sha1(ipad.concat(str2binb(data)), 512 + data.length * 8);\n            return core_sha1(opad.concat(hash), 512 + 160);\n        }\n\n        /*\n         * Add integers, wrapping at 2^32. This uses 16-bit operations internally\n         * to work around bugs in some JS interpreters.\n         */\n        function safe_add(x, y) {\n            var lsw = (x & 0xFFFF) + (y & 0xFFFF);\n            var msw = (x >> 16) + (y >> 16) + (lsw >> 16);\n            return (msw << 16) | (lsw & 0xFFFF);\n        }\n\n        /*\n         * Bitwise rotate a 32-bit number to the left.\n         */\n        function rol(num, cnt) {\n            return (num << cnt) | (num >>> (32 - cnt));\n        }\n\n        /*\n         * Convert an 8-bit or 16-bit string to an array of big-endian words\n         * In 8-bit function, characters >255 have their hi-byte silently ignored.\n         */\n        function str2binb(str) {\n            var bin = [];\n            var mask = 255;\n            for (var i = 0; i < str.length * 8; i += 8) {\n                bin[i >> 5] |= (str.charCodeAt(i / 8) & mask) << (24 - i % 32);\n            }\n            return bin;\n        }\n\n        /*\n         * Convert an array of big-endian words to a string\n         */\n        function binb2str(bin) {\n            var str = \"\";\n            var mask = 255;\n            for (var i = 0; i < bin.length * 32; i += 8) {\n                str += String.fromCharCode((bin[i >> 5] >>> (24 - i % 32)) & mask);\n            }\n            return str;\n        }\n\n        /*\n         * Convert an array of big-endian words to a base-64 string\n         */\n        function binb2b64(binarray) {\n            var tab = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n            var str = \"\";\n            var triplet, j;\n            for (var i = 0; i < binarray.length * 4; i += 3) {\n                triplet = (((binarray[i >> 2] >> 8 * (3 - i % 4)) & 0xFF) << 16) |\n                    (((binarray[i + 1 >> 2] >> 8 * (3 - (i + 1) % 4)) & 0xFF) << 8 ) |\n                    ((binarray[i + 2 >> 2] >> 8 * (3 - (i + 2) % 4)) & 0xFF);\n                for (j = 0; j < 4; j++) {\n                    if (i * 8 + j * 6 > binarray.length * 32) {\n                        str += \"=\";\n                    }\n                    else {\n                        str += tab.charAt((triplet >> 6 * (3 - j)) & 0x3F);\n                    }\n                }\n            }\n            return str;\n        }\n\n        /*\n         * These are the functions you'll usually want to call\n         * They take string arguments and return either hex or base-64 encoded strings\n         */\n        return {\n            b64_hmac_sha1: function (key, data) {\n                return binb2b64(core_hmac_sha1(key, data));\n            },\n            b64_sha1: function (s) {\n                return binb2b64(core_sha1(str2binb(s), s.length * 8));\n            },\n            binb2str: binb2str,\n            core_hmac_sha1: core_hmac_sha1,\n            str_hmac_sha1: function (key, data) {\n                return binb2str(core_hmac_sha1(key, data));\n            },\n            str_sha1: function (s) {\n                return binb2str(core_sha1(str2binb(s), s.length * 8));\n            },\n        };\n    }));\n\n    /*\n     * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message\n     * Digest Algorithm, as defined in RFC 1321.\n     * Version 2.1 Copyright (C) Paul Johnston 1999 - 2002.\n     * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet\n     * Distributed under the BSD License\n     * See http://pajhome.org.uk/crypt/md5 for more info.\n     */\n\n    /*\n     * Everything that isn't used by Strophe has been stripped here!\n     */\n\n    (function (root, factory) {\n        if (typeof define === 'function' && define.amd) {\n            define('strophe-md5', function () {\n                return factory();\n            });\n        } else {\n            // Browser globals\n            root.MD5 = factory();\n        }\n    }(this, function (b) {\n        /*\n         * Add integers, wrapping at 2^32. This uses 16-bit operations internally\n         * to work around bugs in some JS interpreters.\n         */\n        var safe_add = function (x, y) {\n            var lsw = (x & 0xFFFF) + (y & 0xFFFF);\n            var msw = (x >> 16) + (y >> 16) + (lsw >> 16);\n            return (msw << 16) | (lsw & 0xFFFF);\n        };\n\n        /*\n         * Bitwise rotate a 32-bit number to the left.\n         */\n        var bit_rol = function (num, cnt) {\n            return (num << cnt) | (num >>> (32 - cnt));\n        };\n\n        /*\n         * Convert a string to an array of little-endian words\n         */\n        var str2binl = function (str) {\n            var bin = [];\n            for (var i = 0; i < str.length * 8; i += 8) {\n                bin[i >> 5] |= (str.charCodeAt(i / 8) & 255) << (i % 32);\n            }\n            return bin;\n        };\n\n        /*\n         * Convert an array of little-endian words to a string\n         */\n        var binl2str = function (bin) {\n            var str = \"\";\n            for (var i = 0; i < bin.length * 32; i += 8) {\n                str += String.fromCharCode((bin[i >> 5] >>> (i % 32)) & 255);\n            }\n            return str;\n        };\n\n        /*\n         * Convert an array of little-endian words to a hex string.\n         */\n        var binl2hex = function (binarray) {\n            var hex_tab = \"0123456789abcdef\";\n            var str = \"\";\n            for (var i = 0; i < binarray.length * 4; i++) {\n                str += hex_tab.charAt((binarray[i >> 2] >> ((i % 4) * 8 + 4)) & 0xF) +\n                    hex_tab.charAt((binarray[i >> 2] >> ((i % 4) * 8  )) & 0xF);\n            }\n            return str;\n        };\n\n        /*\n         * These functions implement the four basic operations the algorithm uses.\n         */\n        var md5_cmn = function (q, a, b, x, s, t) {\n            return safe_add(bit_rol(safe_add(safe_add(a, q), safe_add(x, t)), s), b);\n        };\n\n        var md5_ff = function (a, b, c, d, x, s, t) {\n            return md5_cmn((b & c) | ((~b) & d), a, b, x, s, t);\n        };\n\n        var md5_gg = function (a, b, c, d, x, s, t) {\n            return md5_cmn((b & d) | (c & (~d)), a, b, x, s, t);\n        };\n\n        var md5_hh = function (a, b, c, d, x, s, t) {\n            return md5_cmn(b ^ c ^ d, a, b, x, s, t);\n        };\n\n        var md5_ii = function (a, b, c, d, x, s, t) {\n            return md5_cmn(c ^ (b | (~d)), a, b, x, s, t);\n        };\n\n        /*\n         * Calculate the MD5 of an array of little-endian words, and a bit length\n         */\n        var core_md5 = function (x, len) {\n            /* append padding */\n            x[len >> 5] |= 0x80 << ((len) % 32);\n            x[(((len + 64) >>> 9) << 4) + 14] = len;\n\n            var a = 1732584193;\n            var b = -271733879;\n            var c = -1732584194;\n            var d = 271733878;\n\n            var olda, oldb, oldc, oldd;\n            for (var i = 0; i < x.length; i += 16) {\n                olda = a;\n                oldb = b;\n                oldc = c;\n                oldd = d;\n\n                a = md5_ff(a, b, c, d, x[i + 0], 7, -680876936);\n                d = md5_ff(d, a, b, c, x[i + 1], 12, -389564586);\n                c = md5_ff(c, d, a, b, x[i + 2], 17, 606105819);\n                b = md5_ff(b, c, d, a, x[i + 3], 22, -1044525330);\n                a = md5_ff(a, b, c, d, x[i + 4], 7, -176418897);\n                d = md5_ff(d, a, b, c, x[i + 5], 12, 1200080426);\n                c = md5_ff(c, d, a, b, x[i + 6], 17, -1473231341);\n                b = md5_ff(b, c, d, a, x[i + 7], 22, -45705983);\n                a = md5_ff(a, b, c, d, x[i + 8], 7, 1770035416);\n                d = md5_ff(d, a, b, c, x[i + 9], 12, -1958414417);\n                c = md5_ff(c, d, a, b, x[i + 10], 17, -42063);\n                b = md5_ff(b, c, d, a, x[i + 11], 22, -1990404162);\n                a = md5_ff(a, b, c, d, x[i + 12], 7, 1804603682);\n                d = md5_ff(d, a, b, c, x[i + 13], 12, -40341101);\n                c = md5_ff(c, d, a, b, x[i + 14], 17, -1502002290);\n                b = md5_ff(b, c, d, a, x[i + 15], 22, 1236535329);\n\n                a = md5_gg(a, b, c, d, x[i + 1], 5, -165796510);\n                d = md5_gg(d, a, b, c, x[i + 6], 9, -1069501632);\n                c = md5_gg(c, d, a, b, x[i + 11], 14, 643717713);\n                b = md5_gg(b, c, d, a, x[i + 0], 20, -373897302);\n                a = md5_gg(a, b, c, d, x[i + 5], 5, -701558691);\n                d = md5_gg(d, a, b, c, x[i + 10], 9, 38016083);\n                c = md5_gg(c, d, a, b, x[i + 15], 14, -660478335);\n                b = md5_gg(b, c, d, a, x[i + 4], 20, -405537848);\n                a = md5_gg(a, b, c, d, x[i + 9], 5, 568446438);\n                d = md5_gg(d, a, b, c, x[i + 14], 9, -1019803690);\n                c = md5_gg(c, d, a, b, x[i + 3], 14, -187363961);\n                b = md5_gg(b, c, d, a, x[i + 8], 20, 1163531501);\n                a = md5_gg(a, b, c, d, x[i + 13], 5, -1444681467);\n                d = md5_gg(d, a, b, c, x[i + 2], 9, -51403784);\n                c = md5_gg(c, d, a, b, x[i + 7], 14, 1735328473);\n                b = md5_gg(b, c, d, a, x[i + 12], 20, -1926607734);\n\n                a = md5_hh(a, b, c, d, x[i + 5], 4, -378558);\n                d = md5_hh(d, a, b, c, x[i + 8], 11, -2022574463);\n                c = md5_hh(c, d, a, b, x[i + 11], 16, 1839030562);\n                b = md5_hh(b, c, d, a, x[i + 14], 23, -35309556);\n                a = md5_hh(a, b, c, d, x[i + 1], 4, -1530992060);\n                d = md5_hh(d, a, b, c, x[i + 4], 11, 1272893353);\n                c = md5_hh(c, d, a, b, x[i + 7], 16, -155497632);\n                b = md5_hh(b, c, d, a, x[i + 10], 23, -1094730640);\n                a = md5_hh(a, b, c, d, x[i + 13], 4, 681279174);\n                d = md5_hh(d, a, b, c, x[i + 0], 11, -358537222);\n                c = md5_hh(c, d, a, b, x[i + 3], 16, -722521979);\n                b = md5_hh(b, c, d, a, x[i + 6], 23, 76029189);\n                a = md5_hh(a, b, c, d, x[i + 9], 4, -640364487);\n                d = md5_hh(d, a, b, c, x[i + 12], 11, -421815835);\n                c = md5_hh(c, d, a, b, x[i + 15], 16, 530742520);\n                b = md5_hh(b, c, d, a, x[i + 2], 23, -995338651);\n\n                a = md5_ii(a, b, c, d, x[i + 0], 6, -198630844);\n                d = md5_ii(d, a, b, c, x[i + 7], 10, 1126891415);\n                c = md5_ii(c, d, a, b, x[i + 14], 15, -1416354905);\n                b = md5_ii(b, c, d, a, x[i + 5], 21, -57434055);\n                a = md5_ii(a, b, c, d, x[i + 12], 6, 1700485571);\n                d = md5_ii(d, a, b, c, x[i + 3], 10, -1894986606);\n                c = md5_ii(c, d, a, b, x[i + 10], 15, -1051523);\n                b = md5_ii(b, c, d, a, x[i + 1], 21, -2054922799);\n                a = md5_ii(a, b, c, d, x[i + 8], 6, 1873313359);\n                d = md5_ii(d, a, b, c, x[i + 15], 10, -30611744);\n                c = md5_ii(c, d, a, b, x[i + 6], 15, -1560198380);\n                b = md5_ii(b, c, d, a, x[i + 13], 21, 1309151649);\n                a = md5_ii(a, b, c, d, x[i + 4], 6, -145523070);\n                d = md5_ii(d, a, b, c, x[i + 11], 10, -1120210379);\n                c = md5_ii(c, d, a, b, x[i + 2], 15, 718787259);\n                b = md5_ii(b, c, d, a, x[i + 9], 21, -343485551);\n\n                a = safe_add(a, olda);\n                b = safe_add(b, oldb);\n                c = safe_add(c, oldc);\n                d = safe_add(d, oldd);\n            }\n            return [a, b, c, d];\n        };\n\n        var obj = {\n            /*\n             * These are the functions you'll usually want to call.\n             * They take string arguments and return either hex or base-64 encoded\n             * strings.\n             */\n            hexdigest: function (s) {\n                return binl2hex(core_md5(str2binl(s), s.length * 8));\n            },\n\n            hash: function (s) {\n                return binl2str(core_md5(str2binl(s), s.length * 8));\n            }\n        };\n        return obj;\n    }));\n\n    (function (root, factory) {\n        if (typeof define === 'function' && define.amd) {\n            define('strophe-utils', function () {\n                return factory();\n            });\n        } else {\n            // Browser globals\n            root.stropheUtils = factory();\n        }\n    }(this, function () {\n\n        var utils = {\n\n            utf16to8: function (str) {\n                var i, c;\n                var out = \"\";\n                var len = str.length;\n                for (i = 0; i < len; i++) {\n                    c = str.charCodeAt(i);\n                    if ((c >= 0x0000) && (c <= 0x007F)) {\n                        out += str.charAt(i);\n                    } else if (c > 0x07FF) {\n                        out += String.fromCharCode(0xE0 | ((c >> 12) & 0x0F));\n                        out += String.fromCharCode(0x80 | ((c >> 6) & 0x3F));\n                        out += String.fromCharCode(0x80 | ((c >> 0) & 0x3F));\n                    } else {\n                        out += String.fromCharCode(0xC0 | ((c >> 6) & 0x1F));\n                        out += String.fromCharCode(0x80 | ((c >> 0) & 0x3F));\n                    }\n                }\n                return out;\n            },\n\n            addCookies: function (cookies) {\n                /* Parameters:\n                 *  (Object) cookies - either a map of cookie names\n                 *    to string values or to maps of cookie values.\n                 *\n                 * For example:\n                 * { \"myCookie\": \"1234\" }\n                 *\n                 * or:\n                 * { \"myCookie\": {\n                 *      \"value\": \"1234\",\n                 *      \"domain\": \".example.org\",\n                 *      \"path\": \"/\",\n                 *      \"expires\": expirationDate\n                 *      }\n                 *  }\n                 *\n                 *  These values get passed to Strophe.Connection via\n                 *   options.cookies\n                 */\n                var cookieName, cookieObj, isObj, cookieValue, expires, domain, path;\n                for (cookieName in (cookies || {})) {\n                    expires = '';\n                    domain = '';\n                    path = '';\n                    cookieObj = cookies[cookieName];\n                    isObj = typeof cookieObj == \"object\";\n                    cookieValue = escape(unescape(isObj ? cookieObj.value : cookieObj));\n                    if (isObj) {\n                        expires = cookieObj.expires ? \";expires=\" + cookieObj.expires : '';\n                        domain = cookieObj.domain ? \";domain=\" + cookieObj.domain : '';\n                        path = cookieObj.path ? \";path=\" + cookieObj.path : '';\n                    }\n                    document.cookie =\n                        cookieName + '=' + cookieValue + expires + domain + path;\n                }\n            }\n        };\n        return utils;\n    }));\n\n    /*\n     This program is distributed under the terms of the MIT license.\n     Please see the LICENSE file for details.\n\n     Copyright 2006-2008, OGG, LLC\n     */\n\n    /* jshint undef: true, unused: true:, noarg: true, latedef: true */\n    /* global define */\n\n    (function (root, factory) {\n        if (typeof define === 'function' && define.amd) {\n            define('strophe-polyfill', [], function () {\n                return factory();\n            });\n        } else {\n            // Browser globals\n            return factory();\n        }\n    }(this, function () {\n\n        /** PrivateFunction: Function.prototype.bind\n         *  Bind a function to an instance.\n         *\n         *  This Function object extension method creates a bound method similar\n         *  to those in Python.  This means that the 'this' object will point\n         *  to the instance you want.  See\n         *  <a href='https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Function/bind'>MDC's bind() documentation</a> and\n         *  <a href='http://benjamin.smedbergs.us/blog/2007-01-03/bound-functions-and-function-imports-in-javascript/'>Bound Functions and Function Imports in JavaScript</a>\n         *  for a complete explanation.\n         *\n         *  This extension already exists in some browsers (namely, Firefox 3), but\n         *  we provide it to support those that don't.\n         *\n         *  Parameters:\n         *    (Object) obj - The object that will become 'this' in the bound function.\n         *    (Object) argN - An option argument that will be prepended to the\n         *      arguments given for the function call\n         *\n         *  Returns:\n         *    The bound function.\n         */\n        if (!Function.prototype.bind) {\n            Function.prototype.bind = function (obj /*, arg1, arg2, ... */) {\n                var func = this;\n                var _slice = Array.prototype.slice;\n                var _concat = Array.prototype.concat;\n                var _args = _slice.call(arguments, 1);\n\n                return function () {\n                    return func.apply(obj ? obj : this,\n                        _concat.call(_args,\n                            _slice.call(arguments, 0)));\n                };\n            };\n        }\n\n        /** PrivateFunction: Array.isArray\n         *  This is a polyfill for the ES5 Array.isArray method.\n         */\n        if (!Array.isArray) {\n            Array.isArray = function (arg) {\n                return Object.prototype.toString.call(arg) === '[object Array]';\n            };\n        }\n\n        /** PrivateFunction: Array.prototype.indexOf\n         *  Return the index of an object in an array.\n         *\n         *  This function is not supplied by some JavaScript implementations, so\n         *  we provide it if it is missing.  This code is from:\n         *  http://developer.mozilla.org/En/Core_JavaScript_1.5_Reference:Objects:Array:indexOf\n         *\n         *  Parameters:\n         *    (Object) elt - The object to look for.\n         *    (Integer) from - The index from which to start looking. (optional).\n         *\n         *  Returns:\n         *    The index of elt in the array or -1 if not found.\n         */\n        if (!Array.prototype.indexOf) {\n            Array.prototype.indexOf = function (elt /*, from*/) {\n                var len = this.length;\n\n                var from = Number(arguments[1]) || 0;\n                from = (from < 0) ? Math.ceil(from) : Math.floor(from);\n                if (from < 0) {\n                    from += len;\n                }\n\n                for (; from < len; from++) {\n                    if (from in this && this[from] === elt) {\n                        return from;\n                    }\n                }\n\n                return -1;\n            };\n        }\n    }));\n\n    /*\n     This program is distributed under the terms of the MIT license.\n     Please see the LICENSE file for details.\n\n     Copyright 2006-2008, OGG, LLC\n     */\n\n    /* jshint undef: true, unused: true:, noarg: true, latedef: true */\n    /*global define, document, window, setTimeout, clearTimeout, console, ActiveXObject, DOMParser */\n\n    (function (root, factory) {\n        if (typeof define === 'function' && define.amd) {\n            define('strophe-core', [\n                'strophe-sha1',\n                'strophe-base64',\n                'strophe-md5',\n                'strophe-utils',\n                \"strophe-polyfill\"\n            ], function () {\n                return factory.apply(this, arguments);\n            });\n        } else {\n            // Browser globals\n            var o = factory(root.SHA1, root.Base64, root.MD5, root.stropheUtils);\n            window.Strophe = o.Strophe;\n            window.$build = o.$build;\n            window.$iq = o.$iq;\n            window.$msg = o.$msg;\n            window.$pres = o.$pres;\n            window.SHA1 = o.SHA1;\n            window.Base64 = o.Base64;\n            window.MD5 = o.MD5;\n            window.b64_hmac_sha1 = o.SHA1.b64_hmac_sha1;\n            window.b64_sha1 = o.SHA1.b64_sha1;\n            window.str_hmac_sha1 = o.SHA1.str_hmac_sha1;\n            window.str_sha1 = o.SHA1.str_sha1;\n        }\n    }(this, function (SHA1, Base64, MD5, utils) {\n\n        var Strophe;\n\n        /** Function: $build\n         *  Create a Strophe.Builder.\n         *  This is an alias for 'new Strophe.Builder(name, attrs)'.\n         *\n         *  Parameters:\n         *    (String) name - The root element name.\n         *    (Object) attrs - The attributes for the root element in object notation.\n         *\n         *  Returns:\n         *    A new Strophe.Builder object.\n         */\n        function $build(name, attrs) {\n            return new Strophe.Builder(name, attrs);\n        }\n\n        /** Function: $msg\n         *  Create a Strophe.Builder with a <message/> element as the root.\n         *\n         *  Parameters:\n         *    (Object) attrs - The <message/> element attributes in object notation.\n         *\n         *  Returns:\n         *    A new Strophe.Builder object.\n         */\n        function $msg(attrs) {\n            return new Strophe.Builder(\"message\", attrs);\n        }\n\n        /** Function: $iq\n         *  Create a Strophe.Builder with an <iq/> element as the root.\n         *\n         *  Parameters:\n         *    (Object) attrs - The <iq/> element attributes in object notation.\n         *\n         *  Returns:\n         *    A new Strophe.Builder object.\n         */\n        function $iq(attrs) {\n            return new Strophe.Builder(\"iq\", attrs);\n        }\n\n        /** Function: $pres\n         *  Create a Strophe.Builder with a <presence/> element as the root.\n         *\n         *  Parameters:\n         *    (Object) attrs - The <presence/> element attributes in object notation.\n         *\n         *  Returns:\n         *    A new Strophe.Builder object.\n         */\n        function $pres(attrs) {\n            return new Strophe.Builder(\"presence\", attrs);\n        }\n\n        /** Class: Strophe\n         *  An object container for all Strophe library functions.\n         *\n         *  This class is just a container for all the objects and constants\n         *  used in the library.  It is not meant to be instantiated, but to\n         *  provide a namespace for library objects, constants, and functions.\n         */\n        Strophe = {\n            /** Constant: VERSION\n             *  The version of the Strophe library. Unreleased builds will have\n             *  a version of head-HASH where HASH is a partial revision.\n             */\n            VERSION: \"1.2.8\",\n\n            /** Constants: XMPP Namespace Constants\n             *  Common namespace constants from the XMPP RFCs and XEPs.\n             *\n             *  NS.HTTPBIND - HTTP BIND namespace from XEP 124.\n             *  NS.BOSH - BOSH namespace from XEP 206.\n             *  NS.CLIENT - Main XMPP client namespace.\n             *  NS.AUTH - Legacy authentication namespace.\n             *  NS.ROSTER - Roster operations namespace.\n             *  NS.PROFILE - Profile namespace.\n             *  NS.DISCO_INFO - Service discovery info namespace from XEP 30.\n             *  NS.DISCO_ITEMS - Service discovery items namespace from XEP 30.\n             *  NS.MUC - Multi-User Chat namespace from XEP 45.\n             *  NS.SASL - XMPP SASL namespace from RFC 3920.\n             *  NS.STREAM - XMPP Streams namespace from RFC 3920.\n             *  NS.BIND - XMPP Binding namespace from RFC 3920.\n             *  NS.SESSION - XMPP Session namespace from RFC 3920.\n             *  NS.XHTML_IM - XHTML-IM namespace from XEP 71.\n             *  NS.XHTML - XHTML body namespace from XEP 71.\n             */\n            NS: {\n                HTTPBIND: \"http://jabber.org/protocol/httpbind\",\n                BOSH: \"urn:xmpp:xbosh\",\n                CLIENT: \"jabber:client\",\n                AUTH: \"jabber:iq:auth\",\n                ROSTER: \"jabber:iq:roster\",\n                PROFILE: \"jabber:iq:profile\",\n                DISCO_INFO: \"http://jabber.org/protocol/disco#info\",\n                DISCO_ITEMS: \"http://jabber.org/protocol/disco#items\",\n                MUC: \"http://jabber.org/protocol/muc\",\n                SASL: \"urn:ietf:params:xml:ns:xmpp-sasl\",\n                STREAM: \"http://etherx.jabber.org/streams\",\n                FRAMING: \"urn:ietf:params:xml:ns:xmpp-framing\",\n                BIND: \"urn:ietf:params:xml:ns:xmpp-bind\",\n                SESSION: \"urn:ietf:params:xml:ns:xmpp-session\",\n                VERSION: \"jabber:iq:version\",\n                STANZAS: \"urn:ietf:params:xml:ns:xmpp-stanzas\",\n                XHTML_IM: \"http://jabber.org/protocol/xhtml-im\",\n                XHTML: \"http://www.w3.org/1999/xhtml\"\n            },\n\n            /** Constants: XHTML_IM Namespace\n             *  contains allowed tags, tag attributes, and css properties.\n             *  Used in the createHtml function to filter incoming html into the allowed XHTML-IM subset.\n             *  See http://xmpp.org/extensions/xep-0071.html#profile-summary for the list of recommended\n             *  allowed tags and their attributes.\n             */\n            XHTML: {\n                tags: ['a', 'blockquote', 'br', 'cite', 'em', 'img', 'li', 'ol', 'p', 'span', 'strong', 'ul', 'body'],\n                attributes: {\n                    'a': ['href'],\n                    'blockquote': ['style'],\n                    'br': [],\n                    'cite': ['style'],\n                    'em': [],\n                    'img': ['src', 'alt', 'style', 'height', 'width'],\n                    'li': ['style'],\n                    'ol': ['style'],\n                    'p': ['style'],\n                    'span': ['style'],\n                    'strong': [],\n                    'ul': ['style'],\n                    'body': []\n                },\n                css: ['background-color', 'color', 'font-family', 'font-size', 'font-style', 'font-weight', 'margin-left', 'margin-right', 'text-align', 'text-decoration'],\n                /** Function: XHTML.validTag\n                 *\n                 * Utility method to determine whether a tag is allowed\n                 * in the XHTML_IM namespace.\n                 *\n                 * XHTML tag names are case sensitive and must be lower case.\n                 */\n                validTag: function (tag) {\n                    for (var i = 0; i < Strophe.XHTML.tags.length; i++) {\n                        if (tag == Strophe.XHTML.tags[i]) {\n                            return true;\n                        }\n                    }\n                    return false;\n                },\n                /** Function: XHTML.validAttribute\n                 *\n                 * Utility method to determine whether an attribute is allowed\n                 * as recommended per XEP-0071\n                 *\n                 * XHTML attribute names are case sensitive and must be lower case.\n                 */\n                validAttribute: function (tag, attribute) {\n                    if (typeof Strophe.XHTML.attributes[tag] !== 'undefined' && Strophe.XHTML.attributes[tag].length > 0) {\n                        for (var i = 0; i < Strophe.XHTML.attributes[tag].length; i++) {\n                            if (attribute == Strophe.XHTML.attributes[tag][i]) {\n                                return true;\n                            }\n                        }\n                    }\n                    return false;\n                },\n                validCSS: function (style) {\n                    for (var i = 0; i < Strophe.XHTML.css.length; i++) {\n                        if (style == Strophe.XHTML.css[i]) {\n                            return true;\n                        }\n                    }\n                    return false;\n                }\n            },\n\n            /** Constants: Connection Status Constants\n             *  Connection status constants for use by the connection handler\n             *  callback.\n             *\n             *  Status.ERROR - An error has occurred\n             *  Status.CONNECTING - The connection is currently being made\n             *  Status.CONNFAIL - The connection attempt failed\n             *  Status.AUTHENTICATING - The connection is authenticating\n             *  Status.AUTHFAIL - The authentication attempt failed\n             *  Status.CONNECTED - The connection has succeeded\n             *  Status.DISCONNECTED - The connection has been terminated\n             *  Status.DISCONNECTING - The connection is currently being terminated\n             *  Status.ATTACHED - The connection has been attached\n             *  Status.CONNTIMEOUT - The connection has timed out\n             */\n            Status: {\n                ERROR: 0,\n                CONNECTING: 1,\n                CONNFAIL: 2,\n                AUTHENTICATING: 3,\n                AUTHFAIL: 4,\n                CONNECTED: 5,\n                DISCONNECTED: 6,\n                DISCONNECTING: 7,\n                ATTACHED: 8,\n                REDIRECT: 9,\n                CONNTIMEOUT: 10\n            },\n\n            /** Constants: Log Level Constants\n             *  Logging level indicators.\n             *\n             *  LogLevel.DEBUG - Debug output\n             *  LogLevel.INFO - Informational output\n             *  LogLevel.WARN - Warnings\n             *  LogLevel.ERROR - Errors\n             *  LogLevel.FATAL - Fatal errors\n             */\n            LogLevel: {\n                DEBUG: 0,\n                INFO: 1,\n                WARN: 2,\n                ERROR: 3,\n                FATAL: 4\n            },\n\n            /** PrivateConstants: DOM Element Type Constants\n             *  DOM element types.\n             *\n             *  ElementType.NORMAL - Normal element.\n             *  ElementType.TEXT - Text data element.\n             *  ElementType.FRAGMENT - XHTML fragment element.\n             */\n            ElementType: {\n                NORMAL: 1,\n                TEXT: 3,\n                CDATA: 4,\n                FRAGMENT: 11\n            },\n\n            /** PrivateConstants: Timeout Values\n             *  Timeout values for error states.  These values are in seconds.\n             *  These should not be changed unless you know exactly what you are\n             *  doing.\n             *\n             *  TIMEOUT - Timeout multiplier. A waiting request will be considered\n             *      failed after Math.floor(TIMEOUT * wait) seconds have elapsed.\n             *      This defaults to 1.1, and with default wait, 66 seconds.\n             *  SECONDARY_TIMEOUT - Secondary timeout multiplier. In cases where\n             *      Strophe can detect early failure, it will consider the request\n             *      failed if it doesn't return after\n             *      Math.floor(SECONDARY_TIMEOUT * wait) seconds have elapsed.\n             *      This defaults to 0.1, and with default wait, 6 seconds.\n             */\n            TIMEOUT: 1.1,\n            SECONDARY_TIMEOUT: 0.1,\n\n            /** Function: addNamespace\n             *  This function is used to extend the current namespaces in\n             *  Strophe.NS.  It takes a key and a value with the key being the\n             *  name of the new namespace, with its actual value.\n             *  For example:\n             *  Strophe.addNamespace('PUBSUB', \"http://jabber.org/protocol/pubsub\");\n             *\n             *  Parameters:\n             *    (String) name - The name under which the namespace will be\n             *      referenced under Strophe.NS\n             *    (String) value - The actual namespace.\n             */\n            addNamespace: function (name, value) {\n                Strophe.NS[name] = value;\n            },\n\n            /** Function: forEachChild\n             *  Map a function over some or all child elements of a given element.\n             *\n             *  This is a small convenience function for mapping a function over\n             *  some or all of the children of an element.  If elemName is null, all\n             *  children will be passed to the function, otherwise only children\n             *  whose tag names match elemName will be passed.\n             *\n             *  Parameters:\n             *    (XMLElement) elem - The element to operate on.\n             *    (String) elemName - The child element tag name filter.\n             *    (Function) func - The function to apply to each child.  This\n             *      function should take a single argument, a DOM element.\n             */\n            forEachChild: function (elem, elemName, func) {\n                var i, childNode;\n\n                for (i = 0; i < elem.childNodes.length; i++) {\n                    childNode = elem.childNodes[i];\n                    if (childNode.nodeType == Strophe.ElementType.NORMAL &&\n                        (!elemName || this.isTagEqual(childNode, elemName))) {\n                        func(childNode);\n                    }\n                }\n            },\n\n            /** Function: isTagEqual\n             *  Compare an element's tag name with a string.\n             *\n             *  This function is case sensitive.\n             *\n             *  Parameters:\n             *    (XMLElement) el - A DOM element.\n             *    (String) name - The element name.\n             *\n             *  Returns:\n             *    true if the element's tag name matches _el_, and false\n             *    otherwise.\n             */\n            isTagEqual: function (el, name) {\n                return el.tagName == name;\n            },\n\n            /** PrivateVariable: _xmlGenerator\n             *  _Private_ variable that caches a DOM document to\n             *  generate elements.\n             */\n            _xmlGenerator: null,\n\n            /** PrivateFunction: _makeGenerator\n             *  _Private_ function that creates a dummy XML DOM document to serve as\n             *  an element and text node generator.\n             */\n            _makeGenerator: function () {\n                var doc;\n\n                // IE9 does implement createDocument(); however, using it will cause the browser to leak memory on page unload.\n                // Here, we test for presence of createDocument() plus IE's proprietary documentMode attribute, which would be\n                // less than 10 in the case of IE9 and below.\n                if (document.implementation.createDocument === undefined ||\n                    document.implementation.createDocument && document.documentMode && document.documentMode < 10) {\n                    doc = this._getIEXmlDom();\n                    doc.appendChild(doc.createElement('strophe'));\n                } else {\n                    doc = document.implementation\n                        .createDocument('jabber:client', 'strophe', null);\n                }\n\n                return doc;\n            },\n\n            /** Function: xmlGenerator\n             *  Get the DOM document to generate elements.\n             *\n             *  Returns:\n             *    The currently used DOM document.\n             */\n            xmlGenerator: function () {\n                if (!Strophe._xmlGenerator) {\n                    Strophe._xmlGenerator = Strophe._makeGenerator();\n                }\n                return Strophe._xmlGenerator;\n            },\n\n            /** PrivateFunction: _getIEXmlDom\n             *  Gets IE xml doc object\n             *\n             *  Returns:\n             *    A Microsoft XML DOM Object\n             *  See Also:\n             *    http://msdn.microsoft.com/en-us/library/ms757837%28VS.85%29.aspx\n             */\n            _getIEXmlDom: function () {\n                var doc = null;\n                var docStrings = [\n                    \"Msxml2.DOMDocument.6.0\",\n                    \"Msxml2.DOMDocument.5.0\",\n                    \"Msxml2.DOMDocument.4.0\",\n                    \"MSXML2.DOMDocument.3.0\",\n                    \"MSXML2.DOMDocument\",\n                    \"MSXML.DOMDocument\",\n                    \"Microsoft.XMLDOM\"\n                ];\n\n                for (var d = 0; d < docStrings.length; d++) {\n                    if (doc === null) {\n                        try {\n                            doc = new ActiveXObject(docStrings[d]);\n                        } catch (e) {\n                            doc = null;\n                        }\n                    } else {\n                        break;\n                    }\n                }\n\n                return doc;\n            },\n\n            /** Function: xmlElement\n             *  Create an XML DOM element.\n             *\n             *  This function creates an XML DOM element correctly across all\n             *  implementations. Note that these are not HTML DOM elements, which\n             *  aren't appropriate for XMPP stanzas.\n             *\n             *  Parameters:\n             *    (String) name - The name for the element.\n             *    (Array|Object) attrs - An optional array or object containing\n             *      key/value pairs to use as element attributes. The object should\n             *      be in the format {'key': 'value'} or {key: 'value'}. The array\n             *      should have the format [['key1', 'value1'], ['key2', 'value2']].\n             *    (String) text - The text child data for the element.\n             *\n             *  Returns:\n             *    A new XML DOM element.\n             */\n            xmlElement: function (name) {\n                if (!name) {\n                    return null;\n                }\n\n                var node = Strophe.xmlGenerator().createElement(name);\n\n                // FIXME: this should throw errors if args are the wrong type or\n                // there are more than two optional args\n                var a, i, k;\n                for (a = 1; a < arguments.length; a++) {\n                    var arg = arguments[a];\n                    if (!arg) {\n                        continue;\n                    }\n                    if (typeof(arg) == \"string\" ||\n                        typeof(arg) == \"number\") {\n                        node.appendChild(Strophe.xmlTextNode(arg));\n                    } else if (typeof(arg) == \"object\" &&\n                        typeof(arg.sort) == \"function\") {\n                        for (i = 0; i < arg.length; i++) {\n                            var attr = arg[i];\n                            if (typeof(attr) == \"object\" &&\n                                typeof(attr.sort) == \"function\" &&\n                                attr[1] !== undefined &&\n                                attr[1] !== null) {\n                                node.setAttribute(attr[0], attr[1]);\n                            }\n                        }\n                    } else if (typeof(arg) == \"object\") {\n                        for (k in arg) {\n                            if (arg.hasOwnProperty(k)) {\n                                if (arg[k] !== undefined &&\n                                    arg[k] !== null) {\n                                    node.setAttribute(k, arg[k]);\n                                }\n                            }\n                        }\n                    }\n                }\n\n                return node;\n            },\n\n            /*  Function: xmlescape\n             *  Excapes invalid xml characters.\n             *\n             *  Parameters:\n             *     (String) text - text to escape.\n             *\n             *  Returns:\n             *      Escaped text.\n             */\n            xmlescape: function (text) {\n                text = text.replace(/\\&/g, \"&amp;\");\n                text = text.replace(/</g, \"&lt;\");\n                text = text.replace(/>/g, \"&gt;\");\n                text = text.replace(/'/g, \"&apos;\");\n                text = text.replace(/\"/g, \"&quot;\");\n                return text;\n            },\n\n            /*  Function: xmlunescape\n             *  Unexcapes invalid xml characters.\n             *\n             *  Parameters:\n             *     (String) text - text to unescape.\n             *\n             *  Returns:\n             *      Unescaped text.\n             */\n            xmlunescape: function (text) {\n                text = text.replace(/\\&amp;/g, \"&\");\n                text = text.replace(/&lt;/g, \"<\");\n                text = text.replace(/&gt;/g, \">\");\n                text = text.replace(/&apos;/g, \"'\");\n                text = text.replace(/&quot;/g, \"\\\"\");\n                return text;\n            },\n\n            /** Function: xmlTextNode\n             *  Creates an XML DOM text node.\n             *\n             *  Provides a cross implementation version of document.createTextNode.\n             *\n             *  Parameters:\n             *    (String) text - The content of the text node.\n             *\n             *  Returns:\n             *    A new XML DOM text node.\n             */\n            xmlTextNode: function (text) {\n                return Strophe.xmlGenerator().createTextNode(text);\n            },\n\n            /** Function: xmlHtmlNode\n             *  Creates an XML DOM html node.\n             *\n             *  Parameters:\n             *    (String) html - The content of the html node.\n             *\n             *  Returns:\n             *    A new XML DOM text node.\n             */\n            xmlHtmlNode: function (html) {\n                var node;\n                //ensure text is escaped\n                if (window.DOMParser) {\n                    var parser = new DOMParser();\n                    node = parser.parseFromString(html, \"text/xml\");\n                } else {\n                    node = new ActiveXObject(\"Microsoft.XMLDOM\");\n                    node.async = \"false\";\n                    node.loadXML(html);\n                }\n                return node;\n            },\n\n            /** Function: getText\n             *  Get the concatenation of all text children of an element.\n             *\n             *  Parameters:\n             *    (XMLElement) elem - A DOM element.\n             *\n             *  Returns:\n             *    A String with the concatenated text of all text element children.\n             */\n            getText: function (elem) {\n                if (!elem) {\n                    return null;\n                }\n\n                var str = \"\";\n                if (elem.childNodes.length === 0 && elem.nodeType ==\n                    Strophe.ElementType.TEXT) {\n                    str += elem.nodeValue;\n                }\n\n                for (var i = 0; i < elem.childNodes.length; i++) {\n                    if (elem.childNodes[i].nodeType == Strophe.ElementType.TEXT) {\n                        str += elem.childNodes[i].nodeValue;\n                    }\n                }\n\n                return Strophe.xmlescape(str);\n            },\n\n            /** Function: copyElement\n             *  Copy an XML DOM element.\n             *\n             *  This function copies a DOM element and all its descendants and returns\n             *  the new copy.\n             *\n             *  Parameters:\n             *    (XMLElement) elem - A DOM element.\n             *\n             *  Returns:\n             *    A new, copied DOM element tree.\n             */\n            copyElement: function (elem) {\n                var i, el;\n                if (elem.nodeType == Strophe.ElementType.NORMAL) {\n                    el = Strophe.xmlElement(elem.tagName);\n\n                    for (i = 0; i < elem.attributes.length; i++) {\n                        el.setAttribute(elem.attributes[i].nodeName,\n                            elem.attributes[i].value);\n                    }\n\n                    for (i = 0; i < elem.childNodes.length; i++) {\n                        el.appendChild(Strophe.copyElement(elem.childNodes[i]));\n                    }\n                } else if (elem.nodeType == Strophe.ElementType.TEXT) {\n                    el = Strophe.xmlGenerator().createTextNode(elem.nodeValue);\n                }\n\n                return el;\n            },\n\n\n            /** Function: createHtml\n             *  Copy an HTML DOM element into an XML DOM.\n             *\n             *  This function copies a DOM element and all its descendants and returns\n             *  the new copy.\n             *\n             *  Parameters:\n             *    (HTMLElement) elem - A DOM element.\n             *\n             *  Returns:\n             *    A new, copied DOM element tree.\n             */\n            createHtml: function (elem) {\n                var i, el, j, tag, attribute, value, css, cssAttrs, attr, cssName, cssValue;\n                if (elem.nodeType == Strophe.ElementType.NORMAL) {\n                    tag = elem.nodeName.toLowerCase(); // XHTML tags must be lower case.\n                    if (Strophe.XHTML.validTag(tag)) {\n                        try {\n                            el = Strophe.xmlElement(tag);\n                            for (i = 0; i < Strophe.XHTML.attributes[tag].length; i++) {\n                                attribute = Strophe.XHTML.attributes[tag][i];\n                                value = elem.getAttribute(attribute);\n                                if (typeof value == 'undefined' || value === null || value === '' || value === false || value === 0) {\n                                    continue;\n                                }\n                                if (attribute == 'style' && typeof value == 'object') {\n                                    if (typeof value.cssText != 'undefined') {\n                                        value = value.cssText; // we're dealing with IE, need to get CSS out\n                                    }\n                                }\n                                // filter out invalid css styles\n                                if (attribute == 'style') {\n                                    css = [];\n                                    cssAttrs = value.split(';');\n                                    for (j = 0; j < cssAttrs.length; j++) {\n                                        attr = cssAttrs[j].split(':');\n                                        cssName = attr[0].replace(/^\\s*/, \"\").replace(/\\s*$/, \"\").toLowerCase();\n                                        if (Strophe.XHTML.validCSS(cssName)) {\n                                            cssValue = attr[1].replace(/^\\s*/, \"\").replace(/\\s*$/, \"\");\n                                            css.push(cssName + ': ' + cssValue);\n                                        }\n                                    }\n                                    if (css.length > 0) {\n                                        value = css.join('; ');\n                                        el.setAttribute(attribute, value);\n                                    }\n                                } else {\n                                    el.setAttribute(attribute, value);\n                                }\n                            }\n\n                            for (i = 0; i < elem.childNodes.length; i++) {\n                                el.appendChild(Strophe.createHtml(elem.childNodes[i]));\n                            }\n                        } catch (e) { // invalid elements\n                            el = Strophe.xmlTextNode('');\n                        }\n                    } else {\n                        el = Strophe.xmlGenerator().createDocumentFragment();\n                        for (i = 0; i < elem.childNodes.length; i++) {\n                            el.appendChild(Strophe.createHtml(elem.childNodes[i]));\n                        }\n                    }\n                } else if (elem.nodeType == Strophe.ElementType.FRAGMENT) {\n                    el = Strophe.xmlGenerator().createDocumentFragment();\n                    for (i = 0; i < elem.childNodes.length; i++) {\n                        el.appendChild(Strophe.createHtml(elem.childNodes[i]));\n                    }\n                } else if (elem.nodeType == Strophe.ElementType.TEXT) {\n                    el = Strophe.xmlTextNode(elem.nodeValue);\n                }\n\n                return el;\n            },\n\n            /** Function: escapeNode\n             *  Escape the node part (also called local part) of a JID.\n             *\n             *  Parameters:\n             *    (String) node - A node (or local part).\n             *\n             *  Returns:\n             *    An escaped node (or local part).\n             */\n            escapeNode: function (node) {\n                if (typeof node !== \"string\") {\n                    return node;\n                }\n                return node.replace(/^\\s+|\\s+$/g, '')\n                    .replace(/\\\\/g, \"\\\\5c\")\n                    .replace(/ /g, \"\\\\20\")\n                    .replace(/\\\"/g, \"\\\\22\")\n                    .replace(/\\&/g, \"\\\\26\")\n                    .replace(/\\'/g, \"\\\\27\")\n                    .replace(/\\//g, \"\\\\2f\")\n                    .replace(/:/g, \"\\\\3a\")\n                    .replace(/</g, \"\\\\3c\")\n                    .replace(/>/g, \"\\\\3e\")\n                    .replace(/@/g, \"\\\\40\");\n            },\n\n            /** Function: unescapeNode\n             *  Unescape a node part (also called local part) of a JID.\n             *\n             *  Parameters:\n             *    (String) node - A node (or local part).\n             *\n             *  Returns:\n             *    An unescaped node (or local part).\n             */\n            unescapeNode: function (node) {\n                if (typeof node !== \"string\") {\n                    return node;\n                }\n                return node.replace(/\\\\20/g, \" \")\n                    .replace(/\\\\22/g, '\"')\n                    .replace(/\\\\26/g, \"&\")\n                    .replace(/\\\\27/g, \"'\")\n                    .replace(/\\\\2f/g, \"/\")\n                    .replace(/\\\\3a/g, \":\")\n                    .replace(/\\\\3c/g, \"<\")\n                    .replace(/\\\\3e/g, \">\")\n                    .replace(/\\\\40/g, \"@\")\n                    .replace(/\\\\5c/g, \"\\\\\");\n            },\n\n            /** Function: getNodeFromJid\n             *  Get the node portion of a JID String.\n             *\n             *  Parameters:\n             *    (String) jid - A JID.\n             *\n             *  Returns:\n             *    A String containing the node.\n             */\n            getNodeFromJid: function (jid) {\n                if (jid.indexOf(\"@\") < 0) {\n                    return null;\n                }\n                return jid.split(\"@\")[0];\n            },\n\n            /** Function: getDomainFromJid\n             *  Get the domain portion of a JID String.\n             *\n             *  Parameters:\n             *    (String) jid - A JID.\n             *\n             *  Returns:\n             *    A String containing the domain.\n             */\n            getDomainFromJid: function (jid) {\n                var bare = Strophe.getBareJidFromJid(jid);\n                if (bare.indexOf(\"@\") < 0) {\n                    return bare;\n                } else {\n                    var parts = bare.split(\"@\");\n                    parts.splice(0, 1);\n                    return parts.join('@');\n                }\n            },\n\n            /** Function: getResourceFromJid\n             *  Get the resource portion of a JID String.\n             *\n             *  Parameters:\n             *    (String) jid - A JID.\n             *\n             *  Returns:\n             *    A String containing the resource.\n             */\n            getResourceFromJid: function (jid) {\n                var s = jid.split(\"/\");\n                if (s.length < 2) {\n                    return null;\n                }\n                s.splice(0, 1);\n                return s.join('/');\n            },\n\n            /** Function: getBareJidFromJid\n             *  Get the bare JID from a JID String.\n             *\n             *  Parameters:\n             *    (String) jid - A JID.\n             *\n             *  Returns:\n             *    A String containing the bare JID.\n             */\n            getBareJidFromJid: function (jid) {\n                return jid ? jid.split(\"/\")[0] : null;\n            },\n\n            /** Function: log\n             *  User overrideable logging function.\n             *\n             *  This function is called whenever the Strophe library calls any\n             *  of the logging functions.  The default implementation of this\n             *  function does nothing.  If client code wishes to handle the logging\n             *  messages, it should override this with\n             *  > Strophe.log = function (level, msg) {\n     *  >   (user code here)\n     *  > };\n             *\n             *  Please note that data sent and received over the wire is logged\n             *  via Strophe.Connection.rawInput() and Strophe.Connection.rawOutput().\n             *\n             *  The different levels and their meanings are\n             *\n             *    DEBUG - Messages useful for debugging purposes.\n             *    INFO - Informational messages.  This is mostly information like\n             *      'disconnect was called' or 'SASL auth succeeded'.\n             *    WARN - Warnings about potential problems.  This is mostly used\n             *      to report transient connection errors like request timeouts.\n             *    ERROR - Some error occurred.\n             *    FATAL - A non-recoverable fatal error occurred.\n             *\n             *  Parameters:\n             *    (Integer) level - The log level of the log message.  This will\n             *      be one of the values in Strophe.LogLevel.\n             *    (String) msg - The log message.\n             */\n            /* jshint ignore:start */\n            log: function (level, msg) {\n                return;\n            },\n            /* jshint ignore:end */\n\n            /** Function: debug\n             *  Log a message at the Strophe.LogLevel.DEBUG level.\n             *\n             *  Parameters:\n             *    (String) msg - The log message.\n             */\n            debug: function (msg) {\n                this.log(this.LogLevel.DEBUG, msg);\n            },\n\n            /** Function: info\n             *  Log a message at the Strophe.LogLevel.INFO level.\n             *\n             *  Parameters:\n             *    (String) msg - The log message.\n             */\n            info: function (msg) {\n                this.log(this.LogLevel.INFO, msg);\n            },\n\n            /** Function: warn\n             *  Log a message at the Strophe.LogLevel.WARN level.\n             *\n             *  Parameters:\n             *    (String) msg - The log message.\n             */\n            warn: function (msg) {\n                this.log(this.LogLevel.WARN, msg);\n            },\n\n            /** Function: error\n             *  Log a message at the Strophe.LogLevel.ERROR level.\n             *\n             *  Parameters:\n             *    (String) msg - The log message.\n             */\n            error: function (msg) {\n                this.log(this.LogLevel.ERROR, msg);\n            },\n\n            /** Function: fatal\n             *  Log a message at the Strophe.LogLevel.FATAL level.\n             *\n             *  Parameters:\n             *    (String) msg - The log message.\n             */\n            fatal: function (msg) {\n                this.log(this.LogLevel.FATAL, msg);\n            },\n\n            /** Function: serialize\n             *  Render a DOM element and all descendants to a String.\n             *\n             *  Parameters:\n             *    (XMLElement) elem - A DOM element.\n             *\n             *  Returns:\n             *    The serialized element tree as a String.\n             */\n            serialize: function (elem) {\n                var result;\n\n                if (!elem) {\n                    return null;\n                }\n\n                if (typeof(elem.tree) === \"function\") {\n                    elem = elem.tree();\n                }\n\n                var nodeName = elem.nodeName;\n                var i, child;\n\n                if (elem.getAttribute(\"_realname\")) {\n                    nodeName = elem.getAttribute(\"_realname\");\n                }\n\n                result = \"<\" + nodeName;\n                for (i = 0; i < elem.attributes.length; i++) {\n                    if (elem.attributes[i].nodeName != \"_realname\") {\n                        result += \" \" + elem.attributes[i].nodeName +\n                            \"='\" + Strophe.xmlescape(elem.attributes[i].value) + \"'\";\n                    }\n                }\n\n                if (elem.childNodes.length > 0) {\n                    result += \">\";\n                    for (i = 0; i < elem.childNodes.length; i++) {\n                        child = elem.childNodes[i];\n                        switch (child.nodeType) {\n                            case Strophe.ElementType.NORMAL:\n                                // normal element, so recurse\n                                result += Strophe.serialize(child);\n                                break;\n                            case Strophe.ElementType.TEXT:\n                                // text element to escape values\n                                result += Strophe.xmlescape(child.nodeValue);\n                                break;\n                            case Strophe.ElementType.CDATA:\n                                // cdata section so don't escape values\n                                result += \"<![CDATA[\" + child.nodeValue + \"]]>\";\n                        }\n                    }\n                    result += \"</\" + nodeName + \">\";\n                } else {\n                    result += \"/>\";\n                }\n\n                return result;\n            },\n\n            /** PrivateVariable: _requestId\n             *  _Private_ variable that keeps track of the request ids for\n             *  connections.\n             */\n            _requestId: 0,\n\n            /** PrivateVariable: Strophe.connectionPlugins\n             *  _Private_ variable Used to store plugin names that need\n             *  initialization on Strophe.Connection construction.\n             */\n            _connectionPlugins: {},\n\n            /** Function: addConnectionPlugin\n             *  Extends the Strophe.Connection object with the given plugin.\n             *\n             *  Parameters:\n             *    (String) name - The name of the extension.\n             *    (Object) ptype - The plugin's prototype.\n             */\n            addConnectionPlugin: function (name, ptype) {\n                Strophe._connectionPlugins[name] = ptype;\n            }\n        };\n\n        /** Class: Strophe.Builder\n         *  XML DOM builder.\n         *\n         *  This object provides an interface similar to JQuery but for building\n         *  DOM elements easily and rapidly.  All the functions except for toString()\n         *  and tree() return the object, so calls can be chained.  Here's an\n         *  example using the $iq() builder helper.\n         *  > $iq({to: 'you', from: 'me', type: 'get', id: '1'})\n         *  >     .c('query', {xmlns: 'strophe:example'})\n         *  >     .c('example')\n         *  >     .toString()\n         *  The above generates this XML fragment\n         *  > <iq to='you' from='me' type='get' id='1'>\n         *  >   <query xmlns='strophe:example'>\n         *  >     <example/>\n         *  >   </query>\n         *  > </iq>\n         *  The corresponding DOM manipulations to get a similar fragment would be\n         *  a lot more tedious and probably involve several helper variables.\n         *\n         *  Since adding children makes new operations operate on the child, up()\n         *  is provided to traverse up the tree.  To add two children, do\n         *  > builder.c('child1', ...).up().c('child2', ...)\n         *  The next operation on the Builder will be relative to the second child.\n         */\n\n        /** Constructor: Strophe.Builder\n         *  Create a Strophe.Builder object.\n         *\n         *  The attributes should be passed in object notation.  For example\n         *  > var b = new Builder('message', {to: 'you', from: 'me'});\n         *  or\n         *  > var b = new Builder('messsage', {'xml:lang': 'en'});\n         *\n         *  Parameters:\n         *    (String) name - The name of the root element.\n         *    (Object) attrs - The attributes for the root element in object notation.\n         *\n         *  Returns:\n         *    A new Strophe.Builder.\n         */\n        Strophe.Builder = function (name, attrs) {\n            // Set correct namespace for jabber:client elements\n            if (name == \"presence\" || name == \"message\" || name == \"iq\") {\n                if (attrs && !attrs.xmlns) {\n                    attrs.xmlns = Strophe.NS.CLIENT;\n                } else if (!attrs) {\n                    attrs = {xmlns: Strophe.NS.CLIENT};\n                }\n            }\n\n            // Holds the tree being built.\n            this.nodeTree = Strophe.xmlElement(name, attrs);\n\n            // Points to the current operation node.\n            this.node = this.nodeTree;\n        };\n\n        Strophe.Builder.prototype = {\n            /** Function: tree\n             *  Return the DOM tree.\n             *\n             *  This function returns the current DOM tree as an element object.  This\n             *  is suitable for passing to functions like Strophe.Connection.send().\n             *\n             *  Returns:\n             *    The DOM tree as a element object.\n             */\n            tree: function () {\n                return this.nodeTree;\n            },\n\n            /** Function: toString\n             *  Serialize the DOM tree to a String.\n             *\n             *  This function returns a string serialization of the current DOM\n             *  tree.  It is often used internally to pass data to a\n             *  Strophe.Request object.\n             *\n             *  Returns:\n             *    The serialized DOM tree in a String.\n             */\n            toString: function () {\n                return Strophe.serialize(this.nodeTree);\n            },\n\n            /** Function: up\n             *  Make the current parent element the new current element.\n             *\n             *  This function is often used after c() to traverse back up the tree.\n             *  For example, to add two children to the same element\n             *  > builder.c('child1', {}).up().c('child2', {});\n             *\n             *  Returns:\n             *    The Stophe.Builder object.\n             */\n            up: function () {\n                this.node = this.node.parentNode;\n                return this;\n            },\n\n            /** Function: attrs\n             *  Add or modify attributes of the current element.\n             *\n             *  The attributes should be passed in object notation.  This function\n             *  does not move the current element pointer.\n             *\n             *  Parameters:\n             *    (Object) moreattrs - The attributes to add/modify in object notation.\n             *\n             *  Returns:\n             *    The Strophe.Builder object.\n             */\n            attrs: function (moreattrs) {\n                for (var k in moreattrs) {\n                    if (moreattrs.hasOwnProperty(k)) {\n                        if (moreattrs[k] === undefined) {\n                            this.node.removeAttribute(k);\n                        } else {\n                            this.node.setAttribute(k, moreattrs[k]);\n                        }\n                    }\n                }\n                return this;\n            },\n\n            /** Function: c\n             *  Add a child to the current element and make it the new current\n             *  element.\n             *\n             *  This function moves the current element pointer to the child,\n             *  unless text is provided.  If you need to add another child, it\n             *  is necessary to use up() to go back to the parent in the tree.\n             *\n             *  Parameters:\n             *    (String) name - The name of the child.\n             *    (Object) attrs - The attributes of the child in object notation.\n             *    (String) text - The text to add to the child.\n             *\n             *  Returns:\n             *    The Strophe.Builder object.\n             */\n            c: function (name, attrs, text) {\n                var child = Strophe.xmlElement(name, attrs, text);\n                this.node.appendChild(child);\n                if (typeof text !== \"string\" && typeof text !== \"number\") {\n                    this.node = child;\n                }\n                return this;\n            },\n\n            /** Function: cnode\n             *  Add a child to the current element and make it the new current\n             *  element.\n             *\n             *  This function is the same as c() except that instead of using a\n             *  name and an attributes object to create the child it uses an\n             *  existing DOM element object.\n             *\n             *  Parameters:\n             *    (XMLElement) elem - A DOM element.\n             *\n             *  Returns:\n             *    The Strophe.Builder object.\n             */\n            cnode: function (elem) {\n                var impNode;\n                var xmlGen = Strophe.xmlGenerator();\n                try {\n                    impNode = (xmlGen.importNode !== undefined);\n                }\n                catch (e) {\n                    impNode = false;\n                }\n                var newElem = impNode ?\n                    xmlGen.importNode(elem, true) :\n                    Strophe.copyElement(elem);\n                this.node.appendChild(newElem);\n                this.node = newElem;\n                return this;\n            },\n\n            /** Function: t\n             *  Add a child text element.\n             *\n             *  This *does not* make the child the new current element since there\n             *  are no children of text elements.\n             *\n             *  Parameters:\n             *    (String) text - The text data to append to the current element.\n             *\n             *  Returns:\n             *    The Strophe.Builder object.\n             */\n            t: function (text) {\n                var child = Strophe.xmlTextNode(text);\n                this.node.appendChild(child);\n                return this;\n            },\n\n            /** Function: h\n             *  Replace current element contents with the HTML passed in.\n             *\n             *  This *does not* make the child the new current element\n             *\n             *  Parameters:\n             *    (String) html - The html to insert as contents of current element.\n             *\n             *  Returns:\n             *    The Strophe.Builder object.\n             */\n            h: function (html) {\n                var fragment = document.createElement('body');\n\n                // force the browser to try and fix any invalid HTML tags\n                fragment.innerHTML = html;\n\n                // copy cleaned html into an xml dom\n                var xhtml = Strophe.createHtml(fragment);\n\n                while (xhtml.childNodes.length > 0) {\n                    this.node.appendChild(xhtml.childNodes[0]);\n                }\n                return this;\n            }\n        };\n\n        /** PrivateClass: Strophe.Handler\n         *  _Private_ helper class for managing stanza handlers.\n         *\n         *  A Strophe.Handler encapsulates a user provided callback function to be\n         *  executed when matching stanzas are received by the connection.\n         *  Handlers can be either one-off or persistant depending on their\n         *  return value. Returning true will cause a Handler to remain active, and\n         *  returning false will remove the Handler.\n         *\n         *  Users will not use Strophe.Handler objects directly, but instead they\n         *  will use Strophe.Connection.addHandler() and\n         *  Strophe.Connection.deleteHandler().\n         */\n\n        /** PrivateConstructor: Strophe.Handler\n         *  Create and initialize a new Strophe.Handler.\n         *\n         *  Parameters:\n         *    (Function) handler - A function to be executed when the handler is run.\n         *    (String) ns - The namespace to match.\n         *    (String) name - The element name to match.\n         *    (String) type - The element type to match.\n         *    (String) id - The element id attribute to match.\n         *    (String) from - The element from attribute to match.\n         *    (Object) options - Handler options\n         *\n         *  Returns:\n         *    A new Strophe.Handler object.\n         */\n        Strophe.Handler = function (handler, ns, name, type, id, from, options) {\n            this.handler = handler;\n            this.ns = ns;\n            this.name = name;\n            this.type = type;\n            this.id = id;\n            this.options = options || {matchBare: false};\n\n            // default matchBare to false if undefined\n            if (!this.options.matchBare) {\n                this.options.matchBare = false;\n            }\n\n            if (this.options.matchBare) {\n                this.from = from ? Strophe.getBareJidFromJid(from) : null;\n            } else {\n                this.from = from;\n            }\n\n            // whether the handler is a user handler or a system handler\n            this.user = true;\n        };\n\n        Strophe.Handler.prototype = {\n            /** PrivateFunction: isMatch\n             *  Tests if a stanza matches the Strophe.Handler.\n             *\n             *  Parameters:\n             *    (XMLElement) elem - The XML element to test.\n             *\n             *  Returns:\n             *    true if the stanza matches and false otherwise.\n             */\n            isMatch: function (elem) {\n                var nsMatch;\n                var from = null;\n\n                if (this.options.matchBare) {\n                    from = Strophe.getBareJidFromJid(elem.getAttribute('from'));\n                } else {\n                    from = elem.getAttribute('from');\n                }\n\n                nsMatch = false;\n                if (!this.ns) {\n                    nsMatch = true;\n                } else {\n                    var that = this;\n                    Strophe.forEachChild(elem, null, function (elem) {\n                        if (elem.getAttribute(\"xmlns\") == that.ns) {\n                            nsMatch = true;\n                        }\n                    });\n\n                    nsMatch = nsMatch || elem.getAttribute(\"xmlns\") == this.ns;\n                }\n\n                var elem_type = elem.getAttribute(\"type\");\n                if (nsMatch &&\n                    (!this.name || Strophe.isTagEqual(elem, this.name)) &&\n                    (!this.type || (Array.isArray(this.type) ? this.type.indexOf(elem_type) != -1 : elem_type == this.type)) &&\n                    (!this.id || elem.getAttribute(\"id\") == this.id) &&\n                    (!this.from || from == this.from)) {\n                    return true;\n                }\n\n                return false;\n            },\n\n            /** PrivateFunction: run\n             *  Run the callback on a matching stanza.\n             *\n             *  Parameters:\n             *    (XMLElement) elem - The DOM element that triggered the\n             *      Strophe.Handler.\n             *\n             *  Returns:\n             *    A boolean indicating if the handler should remain active.\n             */\n            run: function (elem) {\n                var result = null;\n                try {\n                    result = this.handler(elem);\n                } catch (e) {\n                    if (e.sourceURL) {\n                        Strophe.fatal(\"error: \" + this.handler +\n                            \" \" + e.sourceURL + \":\" +\n                            e.line + \" - \" + e.name + \": \" + e.message);\n                    } else if (e.fileName) {\n                        if (typeof(console) != \"undefined\") {\n                            console.trace();\n                            console.error(this.handler, \" - error - \", e, e.message);\n                        }\n                        Strophe.fatal(\"error: \" + this.handler + \" \" +\n                            e.fileName + \":\" + e.lineNumber + \" - \" +\n                            e.name + \": \" + e.message);\n                    } else {\n                        Strophe.fatal(\"error: \" + e.message + \"\\n\" + e.stack);\n                    }\n\n                    throw e;\n                }\n\n                return result;\n            },\n\n            /** PrivateFunction: toString\n             *  Get a String representation of the Strophe.Handler object.\n             *\n             *  Returns:\n             *    A String.\n             */\n            toString: function () {\n                return \"{Handler: \" + this.handler + \"(\" + this.name + \",\" +\n                    this.id + \",\" + this.ns + \")}\";\n            }\n        };\n\n        /** PrivateClass: Strophe.TimedHandler\n         *  _Private_ helper class for managing timed handlers.\n         *\n         *  A Strophe.TimedHandler encapsulates a user provided callback that\n         *  should be called after a certain period of time or at regular\n         *  intervals.  The return value of the callback determines whether the\n         *  Strophe.TimedHandler will continue to fire.\n         *\n         *  Users will not use Strophe.TimedHandler objects directly, but instead\n         *  they will use Strophe.Connection.addTimedHandler() and\n         *  Strophe.Connection.deleteTimedHandler().\n         */\n\n        /** PrivateConstructor: Strophe.TimedHandler\n         *  Create and initialize a new Strophe.TimedHandler object.\n         *\n         *  Parameters:\n         *    (Integer) period - The number of milliseconds to wait before the\n         *      handler is called.\n         *    (Function) handler - The callback to run when the handler fires.  This\n         *      function should take no arguments.\n         *\n         *  Returns:\n         *    A new Strophe.TimedHandler object.\n         */\n        Strophe.TimedHandler = function (period, handler) {\n            this.period = period;\n            this.handler = handler;\n\n            this.lastCalled = new Date().getTime();\n            this.user = true;\n        };\n\n        Strophe.TimedHandler.prototype = {\n            /** PrivateFunction: run\n             *  Run the callback for the Strophe.TimedHandler.\n             *\n             *  Returns:\n             *    true if the Strophe.TimedHandler should be called again, and false\n             *      otherwise.\n             */\n            run: function () {\n                this.lastCalled = new Date().getTime();\n                return this.handler();\n            },\n\n            /** PrivateFunction: reset\n             *  Reset the last called time for the Strophe.TimedHandler.\n             */\n            reset: function () {\n                this.lastCalled = new Date().getTime();\n            },\n\n            /** PrivateFunction: toString\n             *  Get a string representation of the Strophe.TimedHandler object.\n             *\n             *  Returns:\n             *    The string representation.\n             */\n            toString: function () {\n                return \"{TimedHandler: \" + this.handler + \"(\" + this.period + \")}\";\n            }\n        };\n\n        /** Class: Strophe.Connection\n         *  XMPP Connection manager.\n         *\n         *  This class is the main part of Strophe.  It manages a BOSH or websocket\n         *  connection to an XMPP server and dispatches events to the user callbacks\n         *  as data arrives. It supports SASL PLAIN, SASL DIGEST-MD5, SASL SCRAM-SHA1\n         *  and legacy authentication.\n         *\n         *  After creating a Strophe.Connection object, the user will typically\n         *  call connect() with a user supplied callback to handle connection level\n         *  events like authentication failure, disconnection, or connection\n         *  complete.\n         *\n         *  The user will also have several event handlers defined by using\n         *  addHandler() and addTimedHandler().  These will allow the user code to\n         *  respond to interesting stanzas or do something periodically with the\n         *  connection. These handlers will be active once authentication is\n         *  finished.\n         *\n         *  To send data to the connection, use send().\n         */\n\n        /** Constructor: Strophe.Connection\n         *  Create and initialize a Strophe.Connection object.\n         *\n         *  The transport-protocol for this connection will be chosen automatically\n         *  based on the given service parameter. URLs starting with \"ws://\" or\n         *  \"wss://\" will use WebSockets, URLs starting with \"http://\", \"https://\"\n         *  or without a protocol will use BOSH.\n         *\n         *  To make Strophe connect to the current host you can leave out the protocol\n         *  and host part and just pass the path, e.g.\n         *\n         *  > var conn = new Strophe.Connection(\"/http-bind/\");\n         *\n         *  Options common to both Websocket and BOSH:\n         *  ------------------------------------------\n         *\n         *  The \"cookies\" option allows you to pass in cookies to be added to the\n         *  document. These cookies will then be included in the BOSH XMLHttpRequest\n         *  or in the websocket connection.\n         *\n         *  The passed in value must be a map of cookie names and string values:\n         *\n         * { \"myCookie\": {\n *      \"value\": \"1234\",\n *      \"domain\": \".example.org\",\n *      \"path\": \"/\",\n *      \"expires\": expirationDate\n *      }\n *  }\n         *\n         *  Note that cookies can't be set in this way for other domains (i.e. cross-domain).\n         *  Those cookies need to be set under those domains, for example they can be\n         *  set server-side by making a XHR call to that domain to ask it to set any\n         *  necessary cookies.\n         *\n         *  WebSocket options:\n         *  ------------------\n         *\n         *  If you want to connect to the current host with a WebSocket connection you\n         *  can tell Strophe to use WebSockets through a \"protocol\" attribute in the\n         *  optional options parameter. Valid values are \"ws\" for WebSocket and \"wss\"\n         *  for Secure WebSocket.\n         *  So to connect to \"wss://CURRENT_HOSTNAME/xmpp-websocket\" you would call\n         *\n         *  > var conn = new Strophe.Connection(\"/xmpp-websocket/\", {protocol: \"wss\"});\n         *\n         *  Note that relative URLs _NOT_ starting with a \"/\" will also include the path\n         *  of the current site.\n         *\n         *  Also because downgrading security is not permitted by browsers, when using\n         *  relative URLs both BOSH and WebSocket connections will use their secure\n         *  variants if the current connection to the site is also secure (https).\n         *\n         *  BOSH options:\n         *  -------------\n         *\n         *  By adding \"sync\" to the options, you can control if requests will\n         *  be made synchronously or not. The default behaviour is asynchronous.\n         *  If you want to make requests synchronous, make \"sync\" evaluate to true:\n         *  > var conn = new Strophe.Connection(\"/http-bind/\", {sync: true});\n         *\n         *  You can also toggle this on an already established connection:\n         *  > conn.options.sync = true;\n         *\n         *  The \"customHeaders\" option can be used to provide custom HTTP headers to be\n         *  included in the XMLHttpRequests made.\n         *\n         *  The \"keepalive\" option can be used to instruct Strophe to maintain the\n         *  current BOSH session across interruptions such as webpage reloads.\n         *\n         *  It will do this by caching the sessions tokens in sessionStorage, and when\n         *  \"restore\" is called it will check whether there are cached tokens with\n         *  which it can resume an existing session.\n         *\n         *  The \"withCredentials\" option should receive a Boolean value and is used to\n         *  indicate wether cookies should be included in ajax requests (by default\n         *  they're not).\n         *  Set this value to true if you are connecting to a BOSH service\n         *  and for some reason need to send cookies to it.\n         *  In order for this to work cross-domain, the server must also enable\n         *  credentials by setting the Access-Control-Allow-Credentials response header\n         *  to \"true\". For most usecases however this setting should be false (which\n         *  is the default).\n         *  Additionally, when using Access-Control-Allow-Credentials, the\n         *  Access-Control-Allow-Origin header can't be set to the wildcard \"*\", but\n         *  instead must be restricted to actual domains.\n         *\n         *  The \"contentType\" option can be set to change the default Content-Type\n         *  of \"text/xml; charset=utf-8\", which can be useful to reduce the amount of\n         *  CORS preflight requests that are sent to the server.\n         *\n         *  Parameters:\n         *    (String) service - The BOSH or WebSocket service URL.\n         *    (Object) options - A hash of configuration options\n         *\n         *  Returns:\n         *    A new Strophe.Connection object.\n         */\n        Strophe.Connection = function (service, options) {\n            // The service URL\n            this.service = service;\n            // Configuration options\n            this.options = options || {};\n            var proto = this.options.protocol || \"\";\n\n            // Select protocal based on service or options\n            if (service.indexOf(\"ws:\") === 0 || service.indexOf(\"wss:\") === 0 ||\n                proto.indexOf(\"ws\") === 0) {\n                this._proto = new Strophe.Websocket(this);\n            } else {\n                this._proto = new Strophe.Bosh(this);\n            }\n\n            /* The connected JID. */\n            this.jid = \"\";\n            /* the JIDs domain */\n            this.domain = null;\n            /* stream:features */\n            this.features = null;\n\n            // SASL\n            this._sasl_data = {};\n            this.do_session = false;\n            this.do_bind = false;\n\n            // handler lists\n            this.timedHandlers = [];\n            this.handlers = [];\n            this.removeTimeds = [];\n            this.removeHandlers = [];\n            this.addTimeds = [];\n            this.addHandlers = [];\n\n            this._authentication = {};\n            this._idleTimeout = null;\n            this._disconnectTimeout = null;\n\n            this.authenticated = false;\n            this.connected = false;\n            this.disconnecting = false;\n            this.do_authentication = true;\n            this.paused = false;\n            this.restored = false;\n\n            this._data = [];\n            this._uniqueId = 0;\n\n            this._sasl_success_handler = null;\n            this._sasl_failure_handler = null;\n            this._sasl_challenge_handler = null;\n\n            // Max retries before disconnecting\n            this.maxRetries = 5;\n\n            // Call onIdle callback every 1/10th of a second\n            // XXX: setTimeout should be called only with function expressions (23974bc1)\n            this._idleTimeout = setTimeout(function () {\n                this._onIdle();\n            }.bind(this), 100);\n\n            utils.addCookies(this.options.cookies);\n\n            // initialize plugins\n            for (var k in Strophe._connectionPlugins) {\n                if (Strophe._connectionPlugins.hasOwnProperty(k)) {\n                    var ptype = Strophe._connectionPlugins[k];\n                    // jslint complaints about the below line, but this is fine\n                    var F = function () {\n                    }; // jshint ignore:line\n                    F.prototype = ptype;\n                    this[k] = new F();\n                    this[k].init(this);\n                }\n            }\n        };\n\n        Strophe.Connection.prototype = {\n            /** Function: reset\n             *  Reset the connection.\n             *\n             *  This function should be called after a connection is disconnected\n             *  before that connection is reused.\n             */\n            reset: function () {\n                this._proto._reset();\n\n                // SASL\n                this.do_session = false;\n                this.do_bind = false;\n\n                // handler lists\n                this.timedHandlers = [];\n                this.handlers = [];\n                this.removeTimeds = [];\n                this.removeHandlers = [];\n                this.addTimeds = [];\n                this.addHandlers = [];\n                this._authentication = {};\n\n                this.authenticated = false;\n                this.connected = false;\n                this.disconnecting = false;\n                this.restored = false;\n\n                this._data = [];\n                this._requests = [];\n                this._uniqueId = 0;\n            },\n\n            /** Function: pause\n             *  Pause the request manager.\n             *\n             *  This will prevent Strophe from sending any more requests to the\n             *  server.  This is very useful for temporarily pausing\n             *  BOSH-Connections while a lot of send() calls are happening quickly.\n             *  This causes Strophe to send the data in a single request, saving\n             *  many request trips.\n             */\n            pause: function () {\n                this.paused = true;\n            },\n\n            setJid: function (jid) {\n                this.jid = jid;\n                this.authzid = Strophe.getBareJidFromJid(this.jid);\n                this.authcid = Strophe.getNodeFromJid(this.jid);\n            },\n\n            getJid: function () {\n                return this.jid;\n            },\n\n            /** Function: resume\n             *  Resume the request manager.\n             *\n             *  This resumes after pause() has been called.\n             */\n\n            resume: function () {\n                this.paused = false;\n            },\n\n            /** Function: getUniqueId\n             *  Generate a unique ID for use in <iq/> elements.\n             *\n             *  All <iq/> stanzas are required to have unique id attributes.  This\n             *  function makes creating these easy.  Each connection instance has\n             *  a counter which starts from zero, and the value of this counter\n             *  plus a colon followed by the suffix becomes the unique id. If no\n             *  suffix is supplied, the counter is used as the unique id.\n             *\n             *  Suffixes are used to make debugging easier when reading the stream\n             *  data, and their use is recommended.  The counter resets to 0 for\n             *  every new connection for the same reason.  For connections to the\n             *  same server that authenticate the same way, all the ids should be\n             *  the same, which makes it easy to see changes.  This is useful for\n             *  automated testing as well.\n             *\n             *  Parameters:\n             *    (String) suffix - A optional suffix to append to the id.\n             *\n             *  Returns:\n             *    A unique string to be used for the id attribute.\n             */\n            getUniqueId: function (suffix) {\n                var uuid = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\n                    var r = Math.random() * 16 | 0,\n                        v = c == 'x' ? r : r & 0x3 | 0x8;\n                    return v.toString(16);\n                });\n                if (typeof(suffix) == \"string\" || typeof(suffix) == \"number\") {\n                    return uuid + \":\" + suffix;\n                } else {\n                    return uuid + \"\";\n                }\n            },\n\n            /** Function: connect\n             *  Starts the connection process.\n             *\n             *  As the connection process proceeds, the user supplied callback will\n             *  be triggered multiple times with status updates.  The callback\n             *  should take two arguments - the status code and the error condition.\n             *\n             *  The status code will be one of the values in the Strophe.Status\n             *  constants.  The error condition will be one of the conditions\n             *  defined in RFC 3920 or the condition 'strophe-parsererror'.\n             *\n             *  The Parameters _wait_, _hold_ and _route_ are optional and only relevant\n             *  for BOSH connections. Please see XEP 124 for a more detailed explanation\n             *  of the optional parameters.\n             *\n             *  Parameters:\n             *    (String) jid - The user's JID.  This may be a bare JID,\n             *      or a full JID.  If a node is not supplied, SASL ANONYMOUS\n             *      authentication will be attempted.\n             *    (String) pass - The user's password.\n             *    (Function) callback - The connect callback function.\n             *    (Integer) wait - The optional HTTPBIND wait value.  This is the\n             *      time the server will wait before returning an empty result for\n             *      a request.  The default setting of 60 seconds is recommended.\n             *    (Integer) hold - The optional HTTPBIND hold value.  This is the\n             *      number of connections the server will hold at one time.  This\n             *      should almost always be set to 1 (the default).\n             *    (String) route - The optional route value.\n             *    (String) authcid - The optional alternative authentication identity\n             *      (username) if intending to impersonate another user.\n             *      When using the SASL-EXTERNAL authentication mechanism, for example\n             *      with client certificates, then the authcid value is used to\n             *      determine whether an authorization JID (authzid) should be sent to\n             *      the server. The authzid should not be sent to the server if the\n             *      authzid and authcid are the same. So to prevent it from being sent\n             *      (for example when the JID is already contained in the client\n             *      certificate), set authcid to that same JID. See XEP-178 for more\n             *      details.\n             */\n            connect: function (jid, pass, callback, wait, hold, route, authcid) {\n                this.jid = jid;\n                /** Variable: authzid\n                 *  Authorization identity.\n                 */\n                this.authzid = Strophe.getBareJidFromJid(this.jid);\n\n                /** Variable: authcid\n                 *  Authentication identity (User name).\n                 */\n                this.authcid = authcid || Strophe.getNodeFromJid(this.jid);\n\n                /** Variable: pass\n                 *  Authentication identity (User password).\n                 */\n                this.pass = pass;\n\n                /** Variable: servtype\n                 *  Digest MD5 compatibility.\n                 */\n                this.servtype = \"xmpp\";\n\n                this.connect_callback = callback;\n                this.disconnecting = false;\n                this.connected = false;\n                this.authenticated = false;\n                this.restored = false;\n\n                // parse jid for domain\n                this.domain = Strophe.getDomainFromJid(this.jid);\n\n                this._changeConnectStatus(Strophe.Status.CONNECTING, null);\n\n                this._proto._connect(wait, hold, route);\n            },\n\n            /** Function: attach\n             *  Attach to an already created and authenticated BOSH session.\n             *\n             *  This function is provided to allow Strophe to attach to BOSH\n             *  sessions which have been created externally, perhaps by a Web\n             *  application.  This is often used to support auto-login type features\n             *  without putting user credentials into the page.\n             *\n             *  Parameters:\n             *    (String) jid - The full JID that is bound by the session.\n             *    (String) sid - The SID of the BOSH session.\n             *    (String) rid - The current RID of the BOSH session.  This RID\n             *      will be used by the next request.\n             *    (Function) callback The connect callback function.\n             *    (Integer) wait - The optional HTTPBIND wait value.  This is the\n             *      time the server will wait before returning an empty result for\n             *      a request.  The default setting of 60 seconds is recommended.\n             *      Other settings will require tweaks to the Strophe.TIMEOUT value.\n             *    (Integer) hold - The optional HTTPBIND hold value.  This is the\n             *      number of connections the server will hold at one time.  This\n             *      should almost always be set to 1 (the default).\n             *    (Integer) wind - The optional HTTBIND window value.  This is the\n             *      allowed range of request ids that are valid.  The default is 5.\n             */\n            attach: function (jid, sid, rid, callback, wait, hold, wind) {\n                if (this._proto instanceof Strophe.Bosh) {\n                    this._proto._attach(jid, sid, rid, callback, wait, hold, wind);\n                } else {\n                    throw {\n                        name: 'StropheSessionError',\n                        message: 'The \"attach\" method can only be used with a BOSH connection.'\n                    };\n                }\n            },\n\n            /** Function: restore\n             *  Attempt to restore a cached BOSH session.\n             *\n             *  This function is only useful in conjunction with providing the\n             *  \"keepalive\":true option when instantiating a new Strophe.Connection.\n             *\n             *  When \"keepalive\" is set to true, Strophe will cache the BOSH tokens\n             *  RID (Request ID) and SID (Session ID) and then when this function is\n             *  called, it will attempt to restore the session from those cached\n             *  tokens.\n             *\n             *  This function must therefore be called instead of connect or attach.\n             *\n             *  For an example on how to use it, please see examples/restore.js\n             *\n             *  Parameters:\n             *    (String) jid - The user's JID.  This may be a bare JID or a full JID.\n             *    (Function) callback - The connect callback function.\n             *    (Integer) wait - The optional HTTPBIND wait value.  This is the\n             *      time the server will wait before returning an empty result for\n             *      a request.  The default setting of 60 seconds is recommended.\n             *    (Integer) hold - The optional HTTPBIND hold value.  This is the\n             *      number of connections the server will hold at one time.  This\n             *      should almost always be set to 1 (the default).\n             *    (Integer) wind - The optional HTTBIND window value.  This is the\n             *      allowed range of request ids that are valid.  The default is 5.\n             */\n            restore: function (jid, callback, wait, hold, wind) {\n                if (this._sessionCachingSupported()) {\n                    this._proto._restore(jid, callback, wait, hold, wind);\n                } else {\n                    throw {\n                        name: 'StropheSessionError',\n                        message: 'The \"restore\" method can only be used with a BOSH connection.'\n                    };\n                }\n            },\n\n            /** PrivateFunction: _sessionCachingSupported\n             * Checks whether sessionStorage and JSON are supported and whether we're\n             * using BOSH.\n             */\n            _sessionCachingSupported: function () {\n                if (this._proto instanceof Strophe.Bosh) {\n                    if (!JSON) {\n                        return false;\n                    }\n                    try {\n                        window.sessionStorage.setItem('_strophe_', '_strophe_');\n                        window.sessionStorage.removeItem('_strophe_');\n                    } catch (e) {\n                        return false;\n                    }\n                    return true;\n                }\n                return false;\n            },\n\n            /** Function: xmlInput\n             *  User overrideable function that receives XML data coming into the\n             *  connection.\n             *\n             *  The default function does nothing.  User code can override this with\n             *  > Strophe.Connection.xmlInput = function (elem) {\n     *  >   (user code)\n     *  > };\n             *\n             *  Due to limitations of current Browsers' XML-Parsers the opening and closing\n             *  <stream> tag for WebSocket-Connoctions will be passed as selfclosing here.\n             *\n             *  BOSH-Connections will have all stanzas wrapped in a <body> tag. See\n             *  <Strophe.Bosh.strip> if you want to strip this tag.\n             *\n             *  Parameters:\n             *    (XMLElement) elem - The XML data received by the connection.\n             */\n            /* jshint unused:false */\n            xmlInput: function (elem) {\n                return;\n            },\n            /* jshint unused:true */\n\n            /** Function: xmlOutput\n             *  User overrideable function that receives XML data sent to the\n             *  connection.\n             *\n             *  The default function does nothing.  User code can override this with\n             *  > Strophe.Connection.xmlOutput = function (elem) {\n     *  >   (user code)\n     *  > };\n             *\n             *  Due to limitations of current Browsers' XML-Parsers the opening and closing\n             *  <stream> tag for WebSocket-Connoctions will be passed as selfclosing here.\n             *\n             *  BOSH-Connections will have all stanzas wrapped in a <body> tag. See\n             *  <Strophe.Bosh.strip> if you want to strip this tag.\n             *\n             *  Parameters:\n             *    (XMLElement) elem - The XMLdata sent by the connection.\n             */\n            /* jshint unused:false */\n            xmlOutput: function (elem) {\n                return;\n            },\n            /* jshint unused:true */\n\n            /** Function: rawInput\n             *  User overrideable function that receives raw data coming into the\n             *  connection.\n             *\n             *  The default function does nothing.  User code can override this with\n             *  > Strophe.Connection.rawInput = function (data) {\n     *  >   (user code)\n     *  > };\n             *\n             *  Parameters:\n             *    (String) data - The data received by the connection.\n             */\n            /* jshint unused:false */\n            rawInput: function (data) {\n                return;\n            },\n            /* jshint unused:true */\n\n            /** Function: rawOutput\n             *  User overrideable function that receives raw data sent to the\n             *  connection.\n             *\n             *  The default function does nothing.  User code can override this with\n             *  > Strophe.Connection.rawOutput = function (data) {\n     *  >   (user code)\n     *  > };\n             *\n             *  Parameters:\n             *    (String) data - The data sent by the connection.\n             */\n            /* jshint unused:false */\n            rawOutput: function (data) {\n                return;\n            },\n            /* jshint unused:true */\n\n            /** Function: nextValidRid\n             *  User overrideable function that receives the new valid rid.\n             *\n             *  The default function does nothing. User code can override this with\n             *  > Strophe.Connection.nextValidRid = function (rid) {\n     *  >    (user code)\n     *  > };\n             *\n             *  Parameters:\n             *    (Number) rid - The next valid rid\n             */\n            /* jshint unused:false */\n            nextValidRid: function (rid) {\n                return;\n            },\n            /* jshint unused:true */\n\n            /** Function: send\n             *  Send a stanza.\n             *\n             *  This function is called to push data onto the send queue to\n             *  go out over the wire.  Whenever a request is sent to the BOSH\n             *  server, all pending data is sent and the queue is flushed.\n             *\n             *  Parameters:\n             *    (XMLElement |\n             *     [XMLElement] |\n             *     Strophe.Builder) elem - The stanza to send.\n             */\n            send: function (elem) {\n                if (elem === null) {\n                    return;\n                }\n                if (typeof(elem.sort) === \"function\") {\n                    for (var i = 0; i < elem.length; i++) {\n                        this._queueData(elem[i]);\n                    }\n                } else if (typeof(elem.tree) === \"function\") {\n                    this._queueData(elem.tree());\n                } else {\n                    this._queueData(elem);\n                }\n\n                this._proto._send();\n            },\n\n            /** Function: flush\n             *  Immediately send any pending outgoing data.\n             *\n             *  Normally send() queues outgoing data until the next idle period\n             *  (100ms), which optimizes network use in the common cases when\n             *  several send()s are called in succession. flush() can be used to\n             *  immediately send all pending data.\n             */\n            flush: function () {\n                // cancel the pending idle period and run the idle function\n                // immediately\n                clearTimeout(this._idleTimeout);\n                this._onIdle();\n            },\n\n            /** Function: sendIQ\n             *  Helper function to send IQ stanzas.\n             *\n             *  Parameters:\n             *    (XMLElement) elem - The stanza to send.\n             *    (Function) callback - The callback function for a successful request.\n             *    (Function) errback - The callback function for a failed or timed\n             *      out request.  On timeout, the stanza will be null.\n             *    (Integer) timeout - The time specified in milliseconds for a\n             *      timeout to occur.\n             *\n             *  Returns:\n             *    The id used to send the IQ.\n             */\n            sendIQ: function (elem, callback, errback, timeout) {\n                var timeoutHandler = null;\n                var that = this;\n\n                if (typeof(elem.tree) === \"function\") {\n                    elem = elem.tree();\n                }\n                var id = elem.getAttribute('id');\n\n                // inject id if not found\n                if (!id) {\n                    id = this.getUniqueId(\"sendIQ\");\n                    elem.setAttribute(\"id\", id);\n                }\n\n                var expectedFrom = elem.getAttribute(\"to\");\n                var fulljid = this.jid;\n\n                var handler = this.addHandler(function (stanza) {\n                    // remove timeout handler if there is one\n                    if (timeoutHandler) {\n                        that.deleteTimedHandler(timeoutHandler);\n                    }\n\n                    var acceptable = false;\n                    var from = stanza.getAttribute(\"from\");\n                    if (from === expectedFrom ||\n                        (!expectedFrom &&\n                        (from === Strophe.getBareJidFromJid(fulljid) ||\n                        from === Strophe.getDomainFromJid(fulljid) ||\n                        from === fulljid))) {\n                        acceptable = true;\n                    }\n\n                    if (!acceptable) {\n                        throw {\n                            name: \"StropheError\",\n                            message: \"Got answer to IQ from wrong jid:\" + from +\n                            \"\\nExpected jid: \" + expectedFrom\n                        };\n                    }\n\n                    var iqtype = stanza.getAttribute('type');\n                    if (iqtype == 'result') {\n                        if (callback) {\n                            callback(stanza);\n                        }\n                    } else if (iqtype == 'error') {\n                        if (errback) {\n                            errback(stanza);\n                        }\n                    } else {\n                        throw {\n                            name: \"StropheError\",\n                            message: \"Got bad IQ type of \" + iqtype\n                        };\n                    }\n                }, null, 'iq', ['error', 'result'], id);\n\n                // if timeout specified, setup timeout handler.\n                if (timeout) {\n                    timeoutHandler = this.addTimedHandler(timeout, function () {\n                        // get rid of normal handler\n                        that.deleteHandler(handler);\n                        // call errback on timeout with null stanza\n                        if (errback) {\n                            errback(null);\n                        }\n                        return false;\n                    });\n                }\n                this.send(elem);\n                return id;\n            },\n\n            /** PrivateFunction: _queueData\n             *  Queue outgoing data for later sending.  Also ensures that the data\n             *  is a DOMElement.\n             */\n            _queueData: function (element) {\n                if (element === null || !element.tagName || !element.childNodes) {\n                    throw {\n                        name: \"StropheError\",\n                        message: \"Cannot queue non-DOMElement.\"\n                    };\n                }\n                this._data.push(element);\n            },\n\n            /** PrivateFunction: _sendRestart\n             *  Send an xmpp:restart stanza.\n             */\n            _sendRestart: function () {\n                this._data.push(\"restart\");\n                this._proto._sendRestart();\n                // XXX: setTimeout should be called only with function expressions (23974bc1)\n                this._idleTimeout = setTimeout(function () {\n                    this._onIdle();\n                }.bind(this), 100);\n            },\n\n            /** Function: addTimedHandler\n             *  Add a timed handler to the connection.\n             *\n             *  This function adds a timed handler.  The provided handler will\n             *  be called every period milliseconds until it returns false,\n             *  the connection is terminated, or the handler is removed.  Handlers\n             *  that wish to continue being invoked should return true.\n             *\n             *  Because of method binding it is necessary to save the result of\n             *  this function if you wish to remove a handler with\n             *  deleteTimedHandler().\n             *\n             *  Note that user handlers are not active until authentication is\n             *  successful.\n             *\n             *  Parameters:\n             *    (Integer) period - The period of the handler.\n             *    (Function) handler - The callback function.\n             *\n             *  Returns:\n             *    A reference to the handler that can be used to remove it.\n             */\n            addTimedHandler: function (period, handler) {\n                var thand = new Strophe.TimedHandler(period, handler);\n                this.addTimeds.push(thand);\n                return thand;\n            },\n\n            /** Function: deleteTimedHandler\n             *  Delete a timed handler for a connection.\n             *\n             *  This function removes a timed handler from the connection.  The\n             *  handRef parameter is *not* the function passed to addTimedHandler(),\n             *  but is the reference returned from addTimedHandler().\n             *\n             *  Parameters:\n             *    (Strophe.TimedHandler) handRef - The handler reference.\n             */\n            deleteTimedHandler: function (handRef) {\n                // this must be done in the Idle loop so that we don't change\n                // the handlers during iteration\n                this.removeTimeds.push(handRef);\n            },\n\n            /** Function: addHandler\n             *  Add a stanza handler for the connection.\n             *\n             *  This function adds a stanza handler to the connection.  The\n             *  handler callback will be called for any stanza that matches\n             *  the parameters.  Note that if multiple parameters are supplied,\n             *  they must all match for the handler to be invoked.\n             *\n             *  The handler will receive the stanza that triggered it as its argument.\n             *  *The handler should return true if it is to be invoked again;\n             *  returning false will remove the handler after it returns.*\n             *\n             *  As a convenience, the ns parameters applies to the top level element\n             *  and also any of its immediate children.  This is primarily to make\n             *  matching /iq/query elements easy.\n             *\n             *  The options argument contains handler matching flags that affect how\n             *  matches are determined. Currently the only flag is matchBare (a\n             *  boolean). When matchBare is true, the from parameter and the from\n             *  attribute on the stanza will be matched as bare JIDs instead of\n             *  full JIDs. To use this, pass {matchBare: true} as the value of\n             *  options. The default value for matchBare is false.\n             *\n             *  The return value should be saved if you wish to remove the handler\n             *  with deleteHandler().\n             *\n             *  Parameters:\n             *    (Function) handler - The user callback.\n             *    (String) ns - The namespace to match.\n             *    (String) name - The stanza name to match.\n             *    (String) type - The stanza type attribute to match.\n             *    (String) id - The stanza id attribute to match.\n             *    (String) from - The stanza from attribute to match.\n             *    (String) options - The handler options\n             *\n             *  Returns:\n             *    A reference to the handler that can be used to remove it.\n             */\n            addHandler: function (handler, ns, name, type, id, from, options) {\n                var hand = new Strophe.Handler(handler, ns, name, type, id, from, options);\n                this.addHandlers.push(hand);\n                return hand;\n            },\n\n            /** Function: deleteHandler\n             *  Delete a stanza handler for a connection.\n             *\n             *  This function removes a stanza handler from the connection.  The\n             *  handRef parameter is *not* the function passed to addHandler(),\n             *  but is the reference returned from addHandler().\n             *\n             *  Parameters:\n             *    (Strophe.Handler) handRef - The handler reference.\n             */\n            deleteHandler: function (handRef) {\n                // this must be done in the Idle loop so that we don't change\n                // the handlers during iteration\n                this.removeHandlers.push(handRef);\n                // If a handler is being deleted while it is being added,\n                // prevent it from getting added\n                var i = this.addHandlers.indexOf(handRef);\n                if (i >= 0) {\n                    this.addHandlers.splice(i, 1);\n                }\n            },\n\n            /** Function: disconnect\n             *  Start the graceful disconnection process.\n             *\n             *  This function starts the disconnection process.  This process starts\n             *  by sending unavailable presence and sending BOSH body of type\n             *  terminate.  A timeout handler makes sure that disconnection happens\n             *  even if the BOSH server does not respond.\n             *  If the Connection object isn't connected, at least tries to abort all pending requests\n             *  so the connection object won't generate successful requests (which were already opened).\n             *\n             *  The user supplied connection callback will be notified of the\n             *  progress as this process happens.\n             *\n             *  Parameters:\n             *    (String) reason - The reason the disconnect is occuring.\n             */\n            disconnect: function (reason) {\n                this._changeConnectStatus(Strophe.Status.DISCONNECTING, reason);\n\n                Strophe.info(\"Disconnect was called because: \" + reason);\n                if (this.connected) {\n                    var pres = false;\n                    this.disconnecting = true;\n                    if (this.authenticated) {\n                        pres = $pres({\n                            xmlns: Strophe.NS.CLIENT,\n                            type: 'unavailable'\n                        });\n                    }\n                    // setup timeout handler\n                    this._disconnectTimeout = this._addSysTimedHandler(\n                        3000, this._onDisconnectTimeout.bind(this));\n                    this._proto._disconnect(pres);\n                } else {\n                    Strophe.info(\"Disconnect was called before Strophe connected to the server\");\n                    this._proto._abortAllRequests();\n                }\n            },\n\n            /** PrivateFunction: _changeConnectStatus\n             *  _Private_ helper function that makes sure plugins and the user's\n             *  callback are notified of connection status changes.\n             *\n             *  Parameters:\n             *    (Integer) status - the new connection status, one of the values\n             *      in Strophe.Status\n             *    (String) condition - the error condition or null\n             */\n            _changeConnectStatus: function (status, condition) {\n                // notify all plugins listening for status changes\n                for (var k in Strophe._connectionPlugins) {\n                    if (Strophe._connectionPlugins.hasOwnProperty(k)) {\n                        var plugin = this[k];\n                        if (plugin.statusChanged) {\n                            try {\n                                plugin.statusChanged(status, condition);\n                            } catch (err) {\n                                Strophe.error(\"\" + k + \" plugin caused an exception \" +\n                                    \"changing status: \" + err);\n                            }\n                        }\n                    }\n                }\n\n                // notify the user's callback\n                if (this.connect_callback) {\n                    try {\n                        this.connect_callback(status, condition);\n                    } catch (e) {\n                        Strophe.error(\"User connection callback caused an \" +\n                            \"exception: \" + e);\n                    }\n                }\n            },\n\n            /** PrivateFunction: _doDisconnect\n             *  _Private_ function to disconnect.\n             *\n             *  This is the last piece of the disconnection logic.  This resets the\n             *  connection and alerts the user's connection callback.\n             */\n            _doDisconnect: function (condition) {\n                if (typeof this._idleTimeout == \"number\") {\n                    clearTimeout(this._idleTimeout);\n                }\n\n                // Cancel Disconnect Timeout\n                if (this._disconnectTimeout !== null) {\n                    this.deleteTimedHandler(this._disconnectTimeout);\n                    this._disconnectTimeout = null;\n                }\n\n                Strophe.info(\"_doDisconnect was called\");\n                this._proto._doDisconnect();\n\n                this.authenticated = false;\n                this.disconnecting = false;\n                this.restored = false;\n\n                // delete handlers\n                this.handlers = [];\n                this.timedHandlers = [];\n                this.removeTimeds = [];\n                this.removeHandlers = [];\n                this.addTimeds = [];\n                this.addHandlers = [];\n\n                // tell the parent we disconnected\n                this._changeConnectStatus(Strophe.Status.DISCONNECTED, condition);\n                this.connected = false;\n            },\n\n            /** PrivateFunction: _dataRecv\n             *  _Private_ handler to processes incoming data from the the connection.\n             *\n             *  Except for _connect_cb handling the initial connection request,\n             *  this function handles the incoming data for all requests.  This\n             *  function also fires stanza handlers that match each incoming\n             *  stanza.\n             *\n             *  Parameters:\n             *    (Strophe.Request) req - The request that has data ready.\n             *    (string) req - The stanza a raw string (optiona).\n             */\n            _dataRecv: function (req, raw) {\n                Strophe.info(\"_dataRecv called\");\n                WebIM && WebIM.config.isDebug && Strophe.info(JSON.stringify(req));\n                var elem = this._proto._reqToData(req);\n                if (elem === null) {\n                    return;\n                }\n\n                if (this.xmlInput !== Strophe.Connection.prototype.xmlInput) {\n                    if (elem.nodeName === this._proto.strip && elem.childNodes.length) {\n                        this.xmlInput(elem.childNodes[0]);\n                    } else {\n                        this.xmlInput(elem);\n                    }\n                }\n                if (this.rawInput !== Strophe.Connection.prototype.rawInput) {\n                    if (raw) {\n                        this.rawInput(raw);\n                    } else {\n                        this.rawInput(Strophe.serialize(elem));\n                    }\n                }\n\n                // remove handlers scheduled for deletion\n                var i, hand;\n                while (this.removeHandlers.length > 0) {\n                    hand = this.removeHandlers.pop();\n                    i = this.handlers.indexOf(hand);\n                    if (i >= 0) {\n                        this.handlers.splice(i, 1);\n                    }\n                }\n\n                // add handlers scheduled for addition\n                while (this.addHandlers.length > 0) {\n                    this.handlers.push(this.addHandlers.pop());\n                }\n\n                // handle graceful disconnect\n                if (this.disconnecting && this._proto._emptyQueue()) {\n                    this._doDisconnect();\n                    return;\n                }\n\n                var type = elem.getAttribute(\"type\");\n                var cond, conflict;\n                if (type !== null && type == \"terminate\") {\n                    // Don't process stanzas that come in after disconnect\n                    if (this.disconnecting) {\n                        return;\n                    }\n\n                    // an error occurred\n                    cond = elem.getAttribute(\"condition\");\n                    conflict = elem.getElementsByTagName(\"conflict\");\n                    if (cond !== null) {\n                        if (cond == \"remote-stream-error\" && conflict.length > 0) {\n                            cond = \"conflict\";\n                        }\n                        this._changeConnectStatus(Strophe.Status.CONNFAIL, cond);\n                    } else {\n                        this._changeConnectStatus(Strophe.Status.CONNFAIL, \"unknown\");\n                    }\n                    this._doDisconnect(cond);\n                    return;\n                }\n\n                // send each incoming stanza through the handler chain\n                var that = this;\n                Strophe.forEachChild(elem, null, function (child) {\n                    var i, newList;\n                    // process handlers\n                    newList = that.handlers;\n                    that.handlers = [];\n                    for (i = 0; i < newList.length; i++) {\n                        var hand = newList[i];\n                        // encapsulate 'handler.run' not to lose the whole handler list if\n                        // one of the handlers throws an exception\n                        try {\n                            if (hand.isMatch(child) &&\n                                (that.authenticated || !hand.user)) {\n                                if (hand.run(child)) {\n                                    that.handlers.push(hand);\n                                }\n                            } else {\n                                that.handlers.push(hand);\n                            }\n                        } catch (e) {\n                            // if the handler throws an exception, we consider it as false\n                            Strophe.warn('Removing Strophe handlers due to uncaught exception: ' + e.message);\n                        }\n                    }\n                });\n            },\n\n\n            /** Attribute: mechanisms\n             *  SASL Mechanisms available for Conncection.\n             */\n            mechanisms: {},\n\n            /** PrivateFunction: _connect_cb\n             *  _Private_ handler for initial connection request.\n             *\n             *  This handler is used to process the initial connection request\n             *  response from the BOSH server. It is used to set up authentication\n             *  handlers and start the authentication process.\n             *\n             *  SASL authentication will be attempted if available, otherwise\n             *  the code will fall back to legacy authentication.\n             *\n             *  Parameters:\n             *    (Strophe.Request) req - The current request.\n             *    (Function) _callback - low level (xmpp) connect callback function.\n             *      Useful for plugins with their own xmpp connect callback (when their)\n             *      want to do something special).\n             */\n            _connect_cb: function (req, _callback, raw) {\n                Strophe.info(\"_connect_cb was called\");\n\n                this.connected = true;\n\n                var bodyWrap;\n                try {\n                    bodyWrap = this._proto._reqToData(req);\n                } catch (e) {\n                    if (e != \"badformat\") {\n                        throw e;\n                    }\n                    this._changeConnectStatus(Strophe.Status.CONNFAIL, 'bad-format');\n                    this._doDisconnect('bad-format');\n                }\n                if (!bodyWrap) {\n                    return;\n                }\n\n                if (this.xmlInput !== Strophe.Connection.prototype.xmlInput) {\n                    if (bodyWrap.nodeName === this._proto.strip && bodyWrap.childNodes.length) {\n                        this.xmlInput(bodyWrap.childNodes[0]);\n                    } else {\n                        this.xmlInput(bodyWrap);\n                    }\n                }\n                if (this.rawInput !== Strophe.Connection.prototype.rawInput) {\n                    if (raw) {\n                        this.rawInput(raw);\n                    } else {\n                        this.rawInput(Strophe.serialize(bodyWrap));\n                    }\n                }\n\n                var conncheck = this._proto._connect_cb(bodyWrap);\n                if (conncheck === Strophe.Status.CONNFAIL) {\n                    return;\n                }\n\n                this._authentication.sasl_scram_sha1 = false;\n                this._authentication.sasl_plain = false;\n                this._authentication.sasl_digest_md5 = false;\n                this._authentication.sasl_anonymous = false;\n                this._authentication.legacy_auth = false;\n\n                // Check for the stream:features tag\n                var hasFeatures;\n                if (bodyWrap.getElementsByTagNameNS) {\n                    hasFeatures = bodyWrap.getElementsByTagNameNS(Strophe.NS.STREAM, \"features\").length > 0;\n                } else {\n                    hasFeatures = bodyWrap.getElementsByTagName(\"stream:features\").length > 0 || bodyWrap.getElementsByTagName(\"features\").length > 0;\n                }\n                var mechanisms = bodyWrap.getElementsByTagName(\"mechanism\");\n                var matched = [];\n                var i, mech, found_authentication = false;\n                if (!hasFeatures) {\n                    this._proto._no_auth_received(_callback);\n                    return;\n                }\n                if (mechanisms.length > 0) {\n                    for (i = 0; i < mechanisms.length; i++) {\n                        mech = Strophe.getText(mechanisms[i]);\n                        if (this.mechanisms[mech]) matched.push(this.mechanisms[mech]);\n                    }\n                }\n                this._authentication.legacy_auth =\n                    bodyWrap.getElementsByTagName(\"auth\").length > 0;\n                found_authentication = this._authentication.legacy_auth ||\n                    matched.length > 0;\n                if (!found_authentication) {\n                    this._proto._no_auth_received(_callback);\n                    return;\n                }\n                if (this.do_authentication !== false)\n                    this.authenticate(matched);\n            },\n\n            /** Function: authenticate\n             * Set up authentication\n             *\n             *  Contiunues the initial connection request by setting up authentication\n             *  handlers and start the authentication process.\n             *\n             *  SASL authentication will be attempted if available, otherwise\n             *  the code will fall back to legacy authentication.\n             *\n             */\n            authenticate: function (matched) {\n                var i;\n                // Sorting matched mechanisms according to priority.\n                for (i = 0; i < matched.length - 1; ++i) {\n                    var higher = i;\n                    for (var j = i + 1; j < matched.length; ++j) {\n                        if (matched[j].prototype.priority > matched[higher].prototype.priority) {\n                            higher = j;\n                        }\n                    }\n                    if (higher != i) {\n                        var swap = matched[i];\n                        matched[i] = matched[higher];\n                        matched[higher] = swap;\n                    }\n                }\n\n                // run each mechanism\n                var mechanism_found = false;\n                for (i = 0; i < matched.length; ++i) {\n                    if (!matched[i].prototype.test(this)) continue;\n\n                    this._sasl_success_handler = this._addSysHandler(\n                        this._sasl_success_cb.bind(this), null,\n                        \"success\", null, null);\n                    this._sasl_failure_handler = this._addSysHandler(\n                        this._sasl_failure_cb.bind(this), null,\n                        \"failure\", null, null);\n                    this._sasl_challenge_handler = this._addSysHandler(\n                        this._sasl_challenge_cb.bind(this), null,\n                        \"challenge\", null, null);\n\n                    this._sasl_mechanism = new matched[i]();\n                    this._sasl_mechanism.onStart(this);\n\n                    var request_auth_exchange = $build(\"auth\", {\n                        xmlns: Strophe.NS.SASL,\n                        mechanism: this._sasl_mechanism.name\n                    });\n\n                    if (this._sasl_mechanism.isClientFirst) {\n                        var response = this._sasl_mechanism.onChallenge(this, null);\n                        request_auth_exchange.t(Base64.encode(response));\n                    }\n                    this.send(request_auth_exchange.tree());\n                    mechanism_found = true;\n                    break;\n                }\n\n                if (!mechanism_found) {\n                    // if none of the mechanism worked\n                    if (Strophe.getNodeFromJid(this.jid) === null) {\n                        // we don't have a node, which is required for non-anonymous\n                        // client connections\n                        this._changeConnectStatus(Strophe.Status.CONNFAIL,\n                            'x-strophe-bad-non-anon-jid');\n                        this.disconnect('x-strophe-bad-non-anon-jid');\n                    } else {\n                        // fall back to legacy authentication\n                        this._changeConnectStatus(Strophe.Status.AUTHENTICATING, null);\n                        this._addSysHandler(this._auth1_cb.bind(this), null, null,\n                            null, \"_auth_1\");\n                        this.send($iq({\n                            type: \"get\",\n                            to: this.domain,\n                            id: \"_auth_1\"\n                        }).c(\"query\", {\n                            xmlns: Strophe.NS.AUTH\n                        }).c(\"username\", {}).t(Strophe.getNodeFromJid(this.jid)).tree());\n                    }\n                }\n            },\n\n            _sasl_challenge_cb: function (elem) {\n                var challenge = Base64.decode(Strophe.getText(elem));\n                var response = this._sasl_mechanism.onChallenge(this, challenge);\n                var stanza = $build('response', {\n                    xmlns: Strophe.NS.SASL\n                });\n                if (response !== \"\") {\n                    stanza.t(Base64.encode(response));\n                }\n                this.send(stanza.tree());\n                return true;\n            },\n\n            /** PrivateFunction: _auth1_cb\n             *  _Private_ handler for legacy authentication.\n             *\n             *  This handler is called in response to the initial <iq type='get'/>\n             *  for legacy authentication.  It builds an authentication <iq/> and\n             *  sends it, creating a handler (calling back to _auth2_cb()) to\n             *  handle the result\n             *\n             *  Parameters:\n             *    (XMLElement) elem - The stanza that triggered the callback.\n             *\n             *  Returns:\n             *    false to remove the handler.\n             */\n            /* jshint unused:false */\n            _auth1_cb: function (elem) {\n                // build plaintext auth iq\n                var iq = $iq({type: \"set\", id: \"_auth_2\"})\n                    .c('query', {xmlns: Strophe.NS.AUTH})\n                    .c('username', {}).t(Strophe.getNodeFromJid(this.jid))\n                    .up()\n                    .c('password').t(this.pass);\n\n                if (!Strophe.getResourceFromJid(this.jid)) {\n                    // since the user has not supplied a resource, we pick\n                    // a default one here.  unlike other auth methods, the server\n                    // cannot do this for us.\n                    this.jid = Strophe.getBareJidFromJid(this.jid) + '/strophe';\n                }\n                iq.up().c('resource', {}).t(Strophe.getResourceFromJid(this.jid));\n\n                this._addSysHandler(this._auth2_cb.bind(this), null,\n                    null, null, \"_auth_2\");\n                this.send(iq.tree());\n                return false;\n            },\n            /* jshint unused:true */\n\n            /** PrivateFunction: _sasl_success_cb\n             *  _Private_ handler for succesful SASL authentication.\n             *\n             *  Parameters:\n             *    (XMLElement) elem - The matching stanza.\n             *\n             *  Returns:\n             *    false to remove the handler.\n             */\n            _sasl_success_cb: function (elem) {\n                if (this._sasl_data[\"server-signature\"]) {\n                    var serverSignature;\n                    var success = Base64.decode(Strophe.getText(elem));\n                    var attribMatch = /([a-z]+)=([^,]+)(,|$)/;\n                    var matches = success.match(attribMatch);\n                    if (matches[1] == \"v\") {\n                        serverSignature = matches[2];\n                    }\n\n                    if (serverSignature != this._sasl_data[\"server-signature\"]) {\n                        // remove old handlers\n                        this.deleteHandler(this._sasl_failure_handler);\n                        this._sasl_failure_handler = null;\n                        if (this._sasl_challenge_handler) {\n                            this.deleteHandler(this._sasl_challenge_handler);\n                            this._sasl_challenge_handler = null;\n                        }\n\n                        this._sasl_data = {};\n                        return this._sasl_failure_cb(null);\n                    }\n                }\n\n                Strophe.info(\"SASL authentication succeeded.\");\n\n                if (this._sasl_mechanism) {\n                    this._sasl_mechanism.onSuccess();\n                }\n\n                // remove old handlers\n                this.deleteHandler(this._sasl_failure_handler);\n                this._sasl_failure_handler = null;\n                if (this._sasl_challenge_handler) {\n                    this.deleteHandler(this._sasl_challenge_handler);\n                    this._sasl_challenge_handler = null;\n                }\n\n                var streamfeature_handlers = [];\n                var wrapper = function (handlers, elem) {\n                    while (handlers.length) {\n                        this.deleteHandler(handlers.pop());\n                    }\n                    this._sasl_auth1_cb.bind(this)(elem);\n                    return false;\n                };\n                streamfeature_handlers.push(this._addSysHandler(function (elem) {\n                    wrapper.bind(this)(streamfeature_handlers, elem);\n                }.bind(this), null, \"stream:features\", null, null));\n                streamfeature_handlers.push(this._addSysHandler(function (elem) {\n                    wrapper.bind(this)(streamfeature_handlers, elem);\n                }.bind(this), Strophe.NS.STREAM, \"features\", null, null));\n\n                // we must send an xmpp:restart now\n                this._sendRestart();\n\n                return false;\n            },\n\n            /** PrivateFunction: _sasl_auth1_cb\n             *  _Private_ handler to start stream binding.\n             *\n             *  Parameters:\n             *    (XMLElement) elem - The matching stanza.\n             *\n             *  Returns:\n             *    false to remove the handler.\n             */\n            _sasl_auth1_cb: function (elem) {\n                // save stream:features for future usage\n                this.features = elem;\n                var i, child;\n                for (i = 0; i < elem.childNodes.length; i++) {\n                    child = elem.childNodes[i];\n                    if (child.nodeName == 'bind') {\n                        this.do_bind = true;\n                    }\n\n                    if (child.nodeName == 'session') {\n                        this.do_session = true;\n                    }\n                }\n\n                if (!this.do_bind) {\n                    this._changeConnectStatus(Strophe.Status.AUTHFAIL, null);\n                    return false;\n                } else {\n                    this._addSysHandler(this._sasl_bind_cb.bind(this), null, null,\n                        null, \"_bind_auth_2\");\n\n                    var resource = Strophe.getResourceFromJid(this.jid);\n                    if (resource) {\n                        // this.send($iq({type: \"set\", id: \"_bind_auth_2\"})\n                        //     .c('bind', {xmlns: Strophe.NS.BIND})\n                        //     .c('resource', {}).t(resource).tree());\n                        try {\n                            this.send(\n                                $iq({type: \"set\", id: \"_bind_auth_2\"})\n                                    .c('bind', {xmlns: Strophe.NS.BIND})\n                                    .c('resource', {}).t(resource)\n                                    .up()\n                                    .c('os').t('webim')\n                                    .up()\n                                    .c('device_uuid').t('device_uuid')\n                                    .up()\n                                    .c('is_manual_login').t('true')\n                                    .tree()\n                            );\n                        } catch (e) {\n                            console.log(\"Bind Error: \", e.message);\n                        }\n                    } else {\n                        this.send($iq({type: \"set\", id: \"_bind_auth_2\"})\n                            .c('bind', {xmlns: Strophe.NS.BIND})\n                            .tree());\n                    }\n                }\n                return false;\n            },\n\n            /** PrivateFunction: _sasl_bind_cb\n             *  _Private_ handler for binding result and session start.\n             *\n             *  Parameters:\n             *    (XMLElement) elem - The matching stanza.\n             *\n             *  Returns:\n             *    false to remove the handler.\n             */\n            _sasl_bind_cb: function (elem) {\n                if (elem.getAttribute(\"type\") == \"error\") {\n                    Strophe.info(\"SASL binding failed.\");\n                    var conflict = elem.getElementsByTagName(\"conflict\"), condition;\n                    if (conflict.length > 0) {\n                        condition = 'conflict';\n                    }\n                    this._changeConnectStatus(Strophe.Status.AUTHFAIL, condition);\n                    return false;\n                }\n\n                // TODO - need to grab errors\n                var bind = elem.getElementsByTagName(\"bind\");\n                var jidNode;\n                if (bind.length > 0) {\n                    // Grab jid\n                    jidNode = bind[0].getElementsByTagName(\"jid\");\n                    if (jidNode.length > 0) {\n                        this.jid = Strophe.getText(jidNode[0]);\n\n                        if (this.do_session) {\n                            this._addSysHandler(this._sasl_session_cb.bind(this),\n                                null, null, null, \"_session_auth_2\");\n\n                            this.send($iq({type: \"set\", id: \"_session_auth_2\"})\n                                .c('session', {xmlns: Strophe.NS.SESSION})\n                                .tree());\n                        } else {\n                            this.authenticated = true;\n                            this._changeConnectStatus(Strophe.Status.CONNECTED, null);\n                        }\n                    }\n                } else {\n                    Strophe.info(\"SASL binding failed.\");\n                    this._changeConnectStatus(Strophe.Status.AUTHFAIL, null);\n                    return false;\n                }\n            },\n\n            /** PrivateFunction: _sasl_session_cb\n             *  _Private_ handler to finish successful SASL connection.\n             *\n             *  This sets Connection.authenticated to true on success, which\n             *  starts the processing of user handlers.\n             *\n             *  Parameters:\n             *    (XMLElement) elem - The matching stanza.\n             *\n             *  Returns:\n             *    false to remove the handler.\n             */\n            _sasl_session_cb: function (elem) {\n                if (elem.getAttribute(\"type\") == \"result\") {\n                    this.authenticated = true;\n                    this._changeConnectStatus(Strophe.Status.CONNECTED, null);\n                } else if (elem.getAttribute(\"type\") == \"error\") {\n                    Strophe.info(\"Session creation failed.\");\n                    this._changeConnectStatus(Strophe.Status.AUTHFAIL, null);\n                    return false;\n                }\n                return false;\n            },\n\n            /** PrivateFunction: _sasl_failure_cb\n             *  _Private_ handler for SASL authentication failure.\n             *\n             *  Parameters:\n             *    (XMLElement) elem - The matching stanza.\n             *\n             *  Returns:\n             *    false to remove the handler.\n             */\n            /* jshint unused:false */\n            _sasl_failure_cb: function (elem) {\n                // delete unneeded handlers\n                if (this._sasl_success_handler) {\n                    this.deleteHandler(this._sasl_success_handler);\n                    this._sasl_success_handler = null;\n                }\n                if (this._sasl_challenge_handler) {\n                    this.deleteHandler(this._sasl_challenge_handler);\n                    this._sasl_challenge_handler = null;\n                }\n\n                if (this._sasl_mechanism)\n                    this._sasl_mechanism.onFailure();\n                this._changeConnectStatus(Strophe.Status.AUTHFAIL, null);\n                return false;\n            },\n            /* jshint unused:true */\n\n            /** PrivateFunction: _auth2_cb\n             *  _Private_ handler to finish legacy authentication.\n             *\n             *  This handler is called when the result from the jabber:iq:auth\n             *  <iq/> stanza is returned.\n             *\n             *  Parameters:\n             *    (XMLElement) elem - The stanza that triggered the callback.\n             *\n             *  Returns:\n             *    false to remove the handler.\n             */\n            _auth2_cb: function (elem) {\n                if (elem.getAttribute(\"type\") == \"result\") {\n                    this.authenticated = true;\n                    this._changeConnectStatus(Strophe.Status.CONNECTED, null);\n                } else if (elem.getAttribute(\"type\") == \"error\") {\n                    this._changeConnectStatus(Strophe.Status.AUTHFAIL, null);\n                    this.disconnect('authentication failed');\n                }\n                return false;\n            },\n\n            /** PrivateFunction: _addSysTimedHandler\n             *  _Private_ function to add a system level timed handler.\n             *\n             *  This function is used to add a Strophe.TimedHandler for the\n             *  library code.  System timed handlers are allowed to run before\n             *  authentication is complete.\n             *\n             *  Parameters:\n             *    (Integer) period - The period of the handler.\n             *    (Function) handler - The callback function.\n             */\n            _addSysTimedHandler: function (period, handler) {\n                var thand = new Strophe.TimedHandler(period, handler);\n                thand.user = false;\n                this.addTimeds.push(thand);\n                return thand;\n            },\n\n            /** PrivateFunction: _addSysHandler\n             *  _Private_ function to add a system level stanza handler.\n             *\n             *  This function is used to add a Strophe.Handler for the\n             *  library code.  System stanza handlers are allowed to run before\n             *  authentication is complete.\n             *\n             *  Parameters:\n             *    (Function) handler - The callback function.\n             *    (String) ns - The namespace to match.\n             *    (String) name - The stanza name to match.\n             *    (String) type - The stanza type attribute to match.\n             *    (String) id - The stanza id attribute to match.\n             */\n            _addSysHandler: function (handler, ns, name, type, id) {\n                var hand = new Strophe.Handler(handler, ns, name, type, id);\n                hand.user = false;\n                this.addHandlers.push(hand);\n                return hand;\n            },\n\n            /** PrivateFunction: _onDisconnectTimeout\n             *  _Private_ timeout handler for handling non-graceful disconnection.\n             *\n             *  If the graceful disconnect process does not complete within the\n             *  time allotted, this handler finishes the disconnect anyway.\n             *\n             *  Returns:\n             *    false to remove the handler.\n             */\n            _onDisconnectTimeout: function () {\n                Strophe.info(\"_onDisconnectTimeout was called\");\n                this._changeConnectStatus(Strophe.Status.CONNTIMEOUT, null);\n                this._proto._onDisconnectTimeout();\n                // actually disconnect\n                this._doDisconnect();\n                return false;\n            },\n\n            /** PrivateFunction: _onIdle\n             *  _Private_ handler to process events during idle cycle.\n             *\n             *  This handler is called every 100ms to fire timed handlers that\n             *  are ready and keep poll requests going.\n             */\n            _onIdle: function () {\n                var i, thand, since, newList;\n\n                // add timed handlers scheduled for addition\n                // NOTE: we add before remove in the case a timed handler is\n                // added and then deleted before the next _onIdle() call.\n                while (this.addTimeds.length > 0) {\n                    this.timedHandlers.push(this.addTimeds.pop());\n                }\n\n                // remove timed handlers that have been scheduled for deletion\n                while (this.removeTimeds.length > 0) {\n                    thand = this.removeTimeds.pop();\n                    i = this.timedHandlers.indexOf(thand);\n                    if (i >= 0) {\n                        this.timedHandlers.splice(i, 1);\n                    }\n                }\n\n                // call ready timed handlers\n                var now = new Date().getTime();\n                newList = [];\n                for (i = 0; i < this.timedHandlers.length; i++) {\n                    thand = this.timedHandlers[i];\n                    if (this.authenticated || !thand.user) {\n                        since = thand.lastCalled + thand.period;\n                        if (since - now <= 0) {\n                            if (thand.run()) {\n                                newList.push(thand);\n                            }\n                        } else {\n                            newList.push(thand);\n                        }\n                    }\n                }\n                this.timedHandlers = newList;\n\n                clearTimeout(this._idleTimeout);\n\n                this._proto._onIdle();\n\n                // reactivate the timer only if connected\n                if (this.connected) {\n                    // XXX: setTimeout should be called only with function expressions (23974bc1)\n                    this._idleTimeout = setTimeout(function () {\n                        this._onIdle();\n                    }.bind(this), 100);\n                }\n            }\n        };\n\n        /** Class: Strophe.SASLMechanism\n         *\n         *  encapsulates SASL authentication mechanisms.\n         *\n         *  User code may override the priority for each mechanism or disable it completely.\n         *  See <priority> for information about changing priority and <test> for informatian on\n         *  how to disable a mechanism.\n         *\n         *  By default, all mechanisms are enabled and the priorities are\n         *\n         *  EXTERNAL - 60\n         *  OAUTHBEARER - 50\n         *  SCRAM-SHA1 - 40\n         *  DIGEST-MD5 - 30\n         *  PLAIN - 20\n         *  ANONYMOUS - 10\n         */\n\n        /**\n         * PrivateConstructor: Strophe.SASLMechanism\n         * SASL auth mechanism abstraction.\n         *\n         *  Parameters:\n         *    (String) name - SASL Mechanism name.\n         *    (Boolean) isClientFirst - If client should send response first without challenge.\n         *    (Number) priority - Priority.\n         *\n         *  Returns:\n         *    A new Strophe.SASLMechanism object.\n         */\n        Strophe.SASLMechanism = function (name, isClientFirst, priority) {\n            /** PrivateVariable: name\n             *  Mechanism name.\n             */\n            this.name = name;\n            /** PrivateVariable: isClientFirst\n             *  If client sends response without initial server challenge.\n             */\n            this.isClientFirst = isClientFirst;\n            /** Variable: priority\n             *  Determines which <SASLMechanism> is chosen for authentication (Higher is better).\n             *  Users may override this to prioritize mechanisms differently.\n             *\n             *  In the default configuration the priorities are\n             *\n             *  SCRAM-SHA1 - 40\n             *  DIGEST-MD5 - 30\n             *  Plain - 20\n             *\n             *  Example: (This will cause Strophe to choose the mechanism that the server sent first)\n             *\n             *  > Strophe.SASLMD5.priority = Strophe.SASLSHA1.priority;\n             *\n             *  See <SASL mechanisms> for a list of available mechanisms.\n             *\n             */\n            this.priority = priority;\n        };\n\n        Strophe.SASLMechanism.prototype = {\n            /**\n             *  Function: test\n             *  Checks if mechanism able to run.\n             *  To disable a mechanism, make this return false;\n             *\n             *  To disable plain authentication run\n             *  > Strophe.SASLPlain.test = function() {\n   *  >   return false;\n   *  > }\n             *\n             *  See <SASL mechanisms> for a list of available mechanisms.\n             *\n             *  Parameters:\n             *    (Strophe.Connection) connection - Target Connection.\n             *\n             *  Returns:\n             *    (Boolean) If mechanism was able to run.\n             */\n            /* jshint unused:false */\n            test: function (connection) {\n                return true;\n            },\n            /* jshint unused:true */\n\n            /** PrivateFunction: onStart\n             *  Called before starting mechanism on some connection.\n             *\n             *  Parameters:\n             *    (Strophe.Connection) connection - Target Connection.\n             */\n            onStart: function (connection) {\n                this._connection = connection;\n            },\n\n            /** PrivateFunction: onChallenge\n             *  Called by protocol implementation on incoming challenge. If client is\n             *  first (isClientFirst == true) challenge will be null on the first call.\n             *\n             *  Parameters:\n             *    (Strophe.Connection) connection - Target Connection.\n             *    (String) challenge - current challenge to handle.\n             *\n             *  Returns:\n             *    (String) Mechanism response.\n             */\n            /* jshint unused:false */\n            onChallenge: function (connection, challenge) {\n                throw new Error(\"You should implement challenge handling!\");\n            },\n            /* jshint unused:true */\n\n            /** PrivateFunction: onFailure\n             *  Protocol informs mechanism implementation about SASL failure.\n             */\n            onFailure: function () {\n                this._connection = null;\n            },\n\n            /** PrivateFunction: onSuccess\n             *  Protocol informs mechanism implementation about SASL success.\n             */\n            onSuccess: function () {\n                this._connection = null;\n            }\n        };\n\n        /** Constants: SASL mechanisms\n         *  Available authentication mechanisms\n         *\n         *  Strophe.SASLAnonymous - SASL ANONYMOUS authentication.\n         *  Strophe.SASLPlain - SASL PLAIN authentication.\n         *  Strophe.SASLMD5 - SASL DIGEST-MD5 authentication\n         *  Strophe.SASLSHA1 - SASL SCRAM-SHA1 authentication\n         *  Strophe.SASLOAuthBearer - SASL OAuth Bearer authentication\n         *  Strophe.SASLExternal - SASL EXTERNAL authentication\n         */\n\n// Building SASL callbacks\n\n        /** PrivateConstructor: SASLAnonymous\n         *  SASL ANONYMOUS authentication.\n         */\n        Strophe.SASLAnonymous = function () {\n        };\n\n        Strophe.SASLAnonymous.prototype = new Strophe.SASLMechanism(\"ANONYMOUS\", false, 10);\n\n        Strophe.SASLAnonymous.prototype.test = function (connection) {\n            return connection.authcid === null;\n        };\n\n        Strophe.Connection.prototype.mechanisms[Strophe.SASLAnonymous.prototype.name] = Strophe.SASLAnonymous;\n\n        /** PrivateConstructor: SASLPlain\n         *  SASL PLAIN authentication.\n         */\n        Strophe.SASLPlain = function () {\n        };\n\n        Strophe.SASLPlain.prototype = new Strophe.SASLMechanism(\"PLAIN\", true, 20);\n\n        Strophe.SASLPlain.prototype.test = function (connection) {\n            return connection.authcid !== null;\n        };\n\n        Strophe.SASLPlain.prototype.onChallenge = function (connection) {\n            var auth_str = connection.authzid;\n            auth_str = auth_str + \"\\u0000\";\n            auth_str = auth_str + connection.authcid;\n            auth_str = auth_str + \"\\u0000\";\n            auth_str = auth_str + connection.pass;\n            return utils.utf16to8(auth_str);\n        };\n\n        Strophe.Connection.prototype.mechanisms[Strophe.SASLPlain.prototype.name] = Strophe.SASLPlain;\n\n        /** PrivateConstructor: SASLSHA1\n         *  SASL SCRAM SHA 1 authentication.\n         */\n        Strophe.SASLSHA1 = function () {\n        };\n\n        Strophe.SASLSHA1.prototype = new Strophe.SASLMechanism(\"SCRAM-SHA-1\", true, 40);\n\n        Strophe.SASLSHA1.prototype.test = function (connection) {\n            return connection.authcid !== null;\n        };\n\n        Strophe.SASLSHA1.prototype.onChallenge = function (connection, challenge, test_cnonce) {\n            var cnonce = test_cnonce || MD5.hexdigest(Math.random() * 1234567890);\n            var auth_str = \"n=\" + utils.utf16to8(connection.authcid);\n            auth_str += \",r=\";\n            auth_str += cnonce;\n\n            connection._sasl_data.cnonce = cnonce;\n            connection._sasl_data[\"client-first-message-bare\"] = auth_str;\n\n            auth_str = \"n,,\" + auth_str;\n\n            this.onChallenge = function (connection, challenge) {\n                var nonce, salt, iter, Hi, U, U_old, i, k, pass;\n                var clientKey, serverKey, clientSignature;\n                var responseText = \"c=biws,\";\n                var authMessage = connection._sasl_data[\"client-first-message-bare\"] + \",\" +\n                    challenge + \",\";\n                var cnonce = connection._sasl_data.cnonce;\n                var attribMatch = /([a-z]+)=([^,]+)(,|$)/;\n\n                while (challenge.match(attribMatch)) {\n                    var matches = challenge.match(attribMatch);\n                    challenge = challenge.replace(matches[0], \"\");\n                    switch (matches[1]) {\n                        case \"r\":\n                            nonce = matches[2];\n                            break;\n                        case \"s\":\n                            salt = matches[2];\n                            break;\n                        case \"i\":\n                            iter = matches[2];\n                            break;\n                    }\n                }\n\n                if (nonce.substr(0, cnonce.length) !== cnonce) {\n                    connection._sasl_data = {};\n                    return connection._sasl_failure_cb();\n                }\n\n                responseText += \"r=\" + nonce;\n                authMessage += responseText;\n\n                salt = Base64.decode(salt);\n                salt += \"\\x00\\x00\\x00\\x01\";\n\n                pass = utils.utf16to8(connection.pass);\n                Hi = U_old = SHA1.core_hmac_sha1(pass, salt);\n                for (i = 1; i < iter; i++) {\n                    U = SHA1.core_hmac_sha1(pass, SHA1.binb2str(U_old));\n                    for (k = 0; k < 5; k++) {\n                        Hi[k] ^= U[k];\n                    }\n                    U_old = U;\n                }\n                Hi = SHA1.binb2str(Hi);\n\n                clientKey = SHA1.core_hmac_sha1(Hi, \"Client Key\");\n                serverKey = SHA1.str_hmac_sha1(Hi, \"Server Key\");\n                clientSignature = SHA1.core_hmac_sha1(SHA1.str_sha1(SHA1.binb2str(clientKey)), authMessage);\n                connection._sasl_data[\"server-signature\"] = SHA1.b64_hmac_sha1(serverKey, authMessage);\n\n                for (k = 0; k < 5; k++) {\n                    clientKey[k] ^= clientSignature[k];\n                }\n\n                responseText += \",p=\" + Base64.encode(SHA1.binb2str(clientKey));\n                return responseText;\n            }.bind(this);\n\n            return auth_str;\n        };\n\n        Strophe.Connection.prototype.mechanisms[Strophe.SASLSHA1.prototype.name] = Strophe.SASLSHA1;\n\n        /** PrivateConstructor: SASLMD5\n         *  SASL DIGEST MD5 authentication.\n         */\n        Strophe.SASLMD5 = function () {\n        };\n\n        Strophe.SASLMD5.prototype = new Strophe.SASLMechanism(\"DIGEST-MD5\", false, 30);\n\n        Strophe.SASLMD5.prototype.test = function (connection) {\n            return connection.authcid !== null;\n        };\n\n        /** PrivateFunction: _quote\n         *  _Private_ utility function to backslash escape and quote strings.\n         *\n         *  Parameters:\n         *    (String) str - The string to be quoted.\n         *\n         *  Returns:\n         *    quoted string\n         */\n        Strophe.SASLMD5.prototype._quote = function (str) {\n            return '\"' + str.replace(/\\\\/g, \"\\\\\\\\\").replace(/\"/g, '\\\\\"') + '\"';\n            //\" end string workaround for emacs\n        };\n\n\n        Strophe.SASLMD5.prototype.onChallenge = function (connection, challenge, test_cnonce) {\n            var attribMatch = /([a-z]+)=(\"[^\"]+\"|[^,\"]+)(?:,|$)/;\n            var cnonce = test_cnonce || MD5.hexdigest(\"\" + (Math.random() * 1234567890));\n            var realm = \"\";\n            var host = null;\n            var nonce = \"\";\n            var qop = \"\";\n            var matches;\n\n            while (challenge.match(attribMatch)) {\n                matches = challenge.match(attribMatch);\n                challenge = challenge.replace(matches[0], \"\");\n                matches[2] = matches[2].replace(/^\"(.+)\"$/, \"$1\");\n                switch (matches[1]) {\n                    case \"realm\":\n                        realm = matches[2];\n                        break;\n                    case \"nonce\":\n                        nonce = matches[2];\n                        break;\n                    case \"qop\":\n                        qop = matches[2];\n                        break;\n                    case \"host\":\n                        host = matches[2];\n                        break;\n                }\n            }\n\n            var digest_uri = connection.servtype + \"/\" + connection.domain;\n            if (host !== null) {\n                digest_uri = digest_uri + \"/\" + host;\n            }\n\n            var cred = utils.utf16to8(connection.authcid + \":\" + realm + \":\" + this._connection.pass);\n            var A1 = MD5.hash(cred) + \":\" + nonce + \":\" + cnonce;\n            var A2 = 'AUTHENTICATE:' + digest_uri;\n\n            var responseText = \"\";\n            responseText += 'charset=utf-8,';\n            responseText += 'username=' + this._quote(utils.utf16to8(connection.authcid)) + ',';\n            responseText += 'realm=' + this._quote(realm) + ',';\n            responseText += 'nonce=' + this._quote(nonce) + ',';\n            responseText += 'nc=00000001,';\n            responseText += 'cnonce=' + this._quote(cnonce) + ',';\n            responseText += 'digest-uri=' + this._quote(digest_uri) + ',';\n            responseText += 'response=' + MD5.hexdigest(MD5.hexdigest(A1) + \":\" +\n                    nonce + \":00000001:\" +\n                    cnonce + \":auth:\" +\n                    MD5.hexdigest(A2)) + \",\";\n            responseText += 'qop=auth';\n\n            this.onChallenge = function () {\n                return \"\";\n            };\n\n            return responseText;\n        };\n\n        Strophe.Connection.prototype.mechanisms[Strophe.SASLMD5.prototype.name] = Strophe.SASLMD5;\n\n        /** PrivateConstructor: SASLOAuthBearer\n         *  SASL OAuth Bearer authentication.\n         */\n        Strophe.SASLOAuthBearer = function () {\n        };\n\n        Strophe.SASLOAuthBearer.prototype = new Strophe.SASLMechanism(\"OAUTHBEARER\", true, 50);\n\n        Strophe.SASLOAuthBearer.prototype.test = function (connection) {\n            return connection.authcid !== null;\n        };\n\n        Strophe.SASLOAuthBearer.prototype.onChallenge = function (connection) {\n            var auth_str = 'n,a=';\n            auth_str = auth_str + connection.authzid;\n            auth_str = auth_str + ',';\n            auth_str = auth_str + \"\\u0001\";\n            auth_str = auth_str + 'auth=Bearer ';\n            auth_str = auth_str + connection.pass;\n            auth_str = auth_str + \"\\u0001\";\n            auth_str = auth_str + \"\\u0001\";\n            return utils.utf16to8(auth_str);\n        };\n\n        Strophe.Connection.prototype.mechanisms[Strophe.SASLOAuthBearer.prototype.name] = Strophe.SASLOAuthBearer;\n\n\n        /** PrivateConstructor: SASLExternal\n         *  SASL EXTERNAL authentication.\n         *\n         *  The EXTERNAL mechanism allows a client to request the server to use\n         *  credentials established by means external to the mechanism to\n         *  authenticate the client. The external means may be, for instance,\n         *  TLS services.\n         */\n        Strophe.SASLExternal = function () {\n        };\n        Strophe.SASLExternal.prototype = new Strophe.SASLMechanism(\"EXTERNAL\", true, 60);\n\n        Strophe.SASLExternal.prototype.onChallenge = function (connection) {\n            /** According to XEP-178, an authzid SHOULD NOT be presented when the\n             * authcid contained or implied in the client certificate is the JID (i.e.\n             * authzid) with which the user wants to log in as.\n             *\n             * To NOT send the authzid, the user should therefore set the authcid equal\n             * to the JID when instantiating a new Strophe.Connection object.\n             */\n            return connection.authcid === connection.authzid ? '' : connection.authzid;\n        };\n\n        Strophe.Connection.prototype.mechanisms[Strophe.SASLExternal.prototype.name] = Strophe.SASLExternal;\n\n        return {\n            Strophe: Strophe,\n            $build: $build,\n            $msg: $msg,\n            $iq: $iq,\n            $pres: $pres,\n            SHA1: SHA1,\n            Base64: Base64,\n            MD5: MD5,\n        };\n    }));\n\n    /*\n     This program is distributed under the terms of the MIT license.\n     Please see the LICENSE file for details.\n\n     Copyright 2006-2008, OGG, LLC\n     */\n\n    /* jshint undef: true, unused: true:, noarg: true, latedef: true */\n    /* global define, window, setTimeout, clearTimeout, XMLHttpRequest, ActiveXObject, Strophe, $build */\n\n    (function (root, factory) {\n        if (typeof define === 'function' && define.amd) {\n            define('strophe-bosh', ['strophe-core'], function (core) {\n                return factory(\n                    core.Strophe,\n                    core.$build\n                );\n            });\n        } else {\n            // Browser globals\n            return factory(Strophe, $build);\n        }\n    }(this, function (Strophe, $build) {\n\n        /** PrivateClass: Strophe.Request\n         *  _Private_ helper class that provides a cross implementation abstraction\n         *  for a BOSH related XMLHttpRequest.\n         *\n         *  The Strophe.Request class is used internally to encapsulate BOSH request\n         *  information.  It is not meant to be used from user's code.\n         */\n\n        /** PrivateConstructor: Strophe.Request\n         *  Create and initialize a new Strophe.Request object.\n         *\n         *  Parameters:\n         *    (XMLElement) elem - The XML data to be sent in the request.\n         *    (Function) func - The function that will be called when the\n         *      XMLHttpRequest readyState changes.\n         *    (Integer) rid - The BOSH rid attribute associated with this request.\n         *    (Integer) sends - The number of times this same request has been\n         *      sent.\n         */\n        Strophe.Request = function (elem, func, rid, sends) {\n            this.id = ++Strophe._requestId;\n            this.xmlData = elem;\n            this.data = Strophe.serialize(elem);\n            // save original function in case we need to make a new request\n            // from this one.\n            this.origFunc = func;\n            this.func = func;\n            this.rid = rid;\n            this.date = NaN;\n            this.sends = sends || 0;\n            this.abort = false;\n            this.dead = null;\n\n            this.age = function () {\n                if (!this.date) {\n                    return 0;\n                }\n                var now = new Date();\n                return (now - this.date) / 1000;\n            };\n            this.timeDead = function () {\n                if (!this.dead) {\n                    return 0;\n                }\n                var now = new Date();\n                return (now - this.dead) / 1000;\n            };\n            this.xhr = this._newXHR();\n        };\n\n        Strophe.Request.prototype = {\n            /** PrivateFunction: getResponse\n             *  Get a response from the underlying XMLHttpRequest.\n             *\n             *  This function attempts to get a response from the request and checks\n             *  for errors.\n             *\n             *  Throws:\n             *    \"parsererror\" - A parser error occured.\n             *    \"badformat\" - The entity has sent XML that cannot be processed.\n             *\n             *  Returns:\n             *    The DOM element tree of the response.\n             */\n            getResponse: function () {\n                var node = null;\n                if (this.xhr.responseXML && this.xhr.responseXML.documentElement) {\n                    node = this.xhr.responseXML.documentElement;\n                    if (node.tagName == \"parsererror\") {\n                        Strophe.error(\"invalid response received\");\n                        Strophe.error(\"responseText: \" + this.xhr.responseText);\n                        Strophe.error(\"responseXML: \" +\n                            Strophe.serialize(this.xhr.responseXML));\n                        throw \"parsererror\";\n                    }\n                } else if (this.xhr.responseText) {\n                    Strophe.error(\"invalid response received\");\n                    Strophe.error(\"responseText: \" + this.xhr.responseText);\n                    throw \"badformat\";\n                }\n\n                return node;\n            },\n\n            /** PrivateFunction: _newXHR\n             *  _Private_ helper function to create XMLHttpRequests.\n             *\n             *  This function creates XMLHttpRequests across all implementations.\n             *\n             *  Returns:\n             *    A new XMLHttpRequest.\n             */\n            _newXHR: function () {\n                var xhr = null;\n                if (window.XMLHttpRequest) {\n                    xhr = new XMLHttpRequest();\n                    if (xhr.overrideMimeType) {\n                        xhr.overrideMimeType(\"text/xml; charset=utf-8\");\n                    }\n                } else if (window.ActiveXObject) {\n                    xhr = new ActiveXObject(\"Microsoft.XMLHTTP\");\n                }\n                // use Function.bind() to prepend ourselves as an argument\n                xhr.onreadystatechange = this.func.bind(null, this);\n                return xhr;\n            }\n        };\n\n        /** Class: Strophe.Bosh\n         *  _Private_ helper class that handles BOSH Connections\n         *\n         *  The Strophe.Bosh class is used internally by Strophe.Connection\n         *  to encapsulate BOSH sessions. It is not meant to be used from user's code.\n         */\n\n        /** File: bosh.js\n         *  A JavaScript library to enable BOSH in Strophejs.\n         *\n         *  this library uses Bidirectional-streams Over Synchronous HTTP (BOSH)\n         *  to emulate a persistent, stateful, two-way connection to an XMPP server.\n         *  More information on BOSH can be found in XEP 124.\n         */\n\n        /** PrivateConstructor: Strophe.Bosh\n         *  Create and initialize a Strophe.Bosh object.\n         *\n         *  Parameters:\n         *    (Strophe.Connection) connection - The Strophe.Connection that will use BOSH.\n         *\n         *  Returns:\n         *    A new Strophe.Bosh object.\n         */\n        Strophe.Bosh = function (connection) {\n            this._conn = connection;\n            /* request id for body tags */\n            this.rid = Math.floor(Math.random() * 4294967295);\n            /* The current session ID. */\n            this.sid = null;\n\n            // default BOSH values\n            this.hold = 1;\n            this.wait = 60;\n            this.window = 5;\n            this.errors = 0;\n\n            this._requests = [];\n        };\n\n        Strophe.Bosh.prototype = {\n            /** Variable: strip\n             *\n             *  BOSH-Connections will have all stanzas wrapped in a <body> tag when\n             *  passed to <Strophe.Connection.xmlInput> or <Strophe.Connection.xmlOutput>.\n             *  To strip this tag, User code can set <Strophe.Bosh.strip> to \"body\":\n             *\n             *  > Strophe.Bosh.prototype.strip = \"body\";\n             *\n             *  This will enable stripping of the body tag in both\n             *  <Strophe.Connection.xmlInput> and <Strophe.Connection.xmlOutput>.\n             */\n            strip: null,\n\n            /** PrivateFunction: _buildBody\n             *  _Private_ helper function to generate the <body/> wrapper for BOSH.\n             *\n             *  Returns:\n             *    A Strophe.Builder with a <body/> element.\n             */\n            _buildBody: function () {\n                var bodyWrap = $build('body', {\n                    rid: this.rid++,\n                    xmlns: Strophe.NS.HTTPBIND\n                });\n                if (this.sid !== null) {\n                    bodyWrap.attrs({sid: this.sid});\n                }\n                if (this._conn.options.keepalive && this._conn._sessionCachingSupported()) {\n                    this._cacheSession();\n                }\n                return bodyWrap;\n            },\n\n            /** PrivateFunction: _reset\n             *  Reset the connection.\n             *\n             *  This function is called by the reset function of the Strophe Connection\n             */\n            _reset: function () {\n                this.rid = Math.floor(Math.random() * 4294967295);\n                this.sid = null;\n                this.errors = 0;\n                if (this._conn._sessionCachingSupported()) {\n                    window.sessionStorage.removeItem('strophe-bosh-session');\n                }\n\n                this._conn.nextValidRid(this.rid);\n            },\n\n            /** PrivateFunction: _connect\n             *  _Private_ function that initializes the BOSH connection.\n             *\n             *  Creates and sends the Request that initializes the BOSH connection.\n             */\n            _connect: function (wait, hold, route) {\n                this.wait = wait || this.wait;\n                this.hold = hold || this.hold;\n                this.errors = 0;\n\n                // build the body tag\n                var body = this._buildBody().attrs({\n                    to: this._conn.domain,\n                    \"xml:lang\": \"en\",\n                    wait: this.wait,\n                    hold: this.hold,\n                    content: \"text/xml; charset=utf-8\",\n                    ver: \"1.6\",\n                    \"xmpp:version\": \"1.0\",\n                    \"xmlns:xmpp\": Strophe.NS.BOSH\n                });\n\n                if (route) {\n                    body.attrs({\n                        route: route\n                    });\n                }\n\n                var _connect_cb = this._conn._connect_cb;\n\n                this._requests.push(\n                    new Strophe.Request(body.tree(),\n                        this._onRequestStateChange.bind(\n                            this, _connect_cb.bind(this._conn)),\n                        body.tree().getAttribute(\"rid\")));\n                this._throttledRequestHandler();\n            },\n\n            /** PrivateFunction: _attach\n             *  Attach to an already created and authenticated BOSH session.\n             *\n             *  This function is provided to allow Strophe to attach to BOSH\n             *  sessions which have been created externally, perhaps by a Web\n             *  application.  This is often used to support auto-login type features\n             *  without putting user credentials into the page.\n             *\n             *  Parameters:\n             *    (String) jid - The full JID that is bound by the session.\n             *    (String) sid - The SID of the BOSH session.\n             *    (String) rid - The current RID of the BOSH session.  This RID\n             *      will be used by the next request.\n             *    (Function) callback The connect callback function.\n             *    (Integer) wait - The optional HTTPBIND wait value.  This is the\n             *      time the server will wait before returning an empty result for\n             *      a request.  The default setting of 60 seconds is recommended.\n             *      Other settings will require tweaks to the Strophe.TIMEOUT value.\n             *    (Integer) hold - The optional HTTPBIND hold value.  This is the\n             *      number of connections the server will hold at one time.  This\n             *      should almost always be set to 1 (the default).\n             *    (Integer) wind - The optional HTTBIND window value.  This is the\n             *      allowed range of request ids that are valid.  The default is 5.\n             */\n            _attach: function (jid, sid, rid, callback, wait, hold, wind) {\n                this._conn.jid = jid;\n                this.sid = sid;\n                this.rid = rid;\n\n                this._conn.connect_callback = callback;\n\n                this._conn.domain = Strophe.getDomainFromJid(this._conn.jid);\n\n                this._conn.authenticated = true;\n                this._conn.connected = true;\n\n                this.wait = wait || this.wait;\n                this.hold = hold || this.hold;\n                this.window = wind || this.window;\n\n                this._conn._changeConnectStatus(Strophe.Status.ATTACHED, null);\n            },\n\n            /** PrivateFunction: _restore\n             *  Attempt to restore a cached BOSH session\n             *\n             *  Parameters:\n             *    (String) jid - The full JID that is bound by the session.\n             *      This parameter is optional but recommended, specifically in cases\n             *      where prebinded BOSH sessions are used where it's important to know\n             *      that the right session is being restored.\n             *    (Function) callback The connect callback function.\n             *    (Integer) wait - The optional HTTPBIND wait value.  This is the\n             *      time the server will wait before returning an empty result for\n             *      a request.  The default setting of 60 seconds is recommended.\n             *      Other settings will require tweaks to the Strophe.TIMEOUT value.\n             *    (Integer) hold - The optional HTTPBIND hold value.  This is the\n             *      number of connections the server will hold at one time.  This\n             *      should almost always be set to 1 (the default).\n             *    (Integer) wind - The optional HTTBIND window value.  This is the\n             *      allowed range of request ids that are valid.  The default is 5.\n             */\n            _restore: function (jid, callback, wait, hold, wind) {\n                var session = JSON.parse(window.sessionStorage.getItem('strophe-bosh-session'));\n                if (typeof session !== \"undefined\" &&\n                    session !== null &&\n                    session.rid &&\n                    session.sid &&\n                    session.jid &&\n                    (typeof jid === \"undefined\" || jid === null || Strophe.getBareJidFromJid(session.jid) == Strophe.getBareJidFromJid(jid))) {\n                    this._conn.restored = true;\n                    this._attach(session.jid, session.sid, session.rid, callback, wait, hold, wind);\n                } else {\n                    throw {name: \"StropheSessionError\", message: \"_restore: no restoreable session.\"};\n                }\n            },\n\n            /** PrivateFunction: _cacheSession\n             *  _Private_ handler for the beforeunload event.\n             *\n             *  This handler is used to process the Bosh-part of the initial request.\n             *  Parameters:\n             *    (Strophe.Request) bodyWrap - The received stanza.\n             */\n            _cacheSession: function () {\n                if (this._conn.authenticated) {\n                    if (this._conn.jid && this.rid && this.sid) {\n                        window.sessionStorage.setItem('strophe-bosh-session', JSON.stringify({\n                            'jid': this._conn.jid,\n                            'rid': this.rid,\n                            'sid': this.sid\n                        }));\n                    }\n                } else {\n                    window.sessionStorage.removeItem('strophe-bosh-session');\n                }\n            },\n\n            /** PrivateFunction: _connect_cb\n             *  _Private_ handler for initial connection request.\n             *\n             *  This handler is used to process the Bosh-part of the initial request.\n             *  Parameters:\n             *    (Strophe.Request) bodyWrap - The received stanza.\n             */\n            _connect_cb: function (bodyWrap) {\n                var typ = bodyWrap.getAttribute(\"type\");\n                var cond, conflict;\n                if (typ !== null && typ == \"terminate\") {\n                    // an error occurred\n                    cond = bodyWrap.getAttribute(\"condition\");\n                    Strophe.error(\"BOSH-Connection failed: \" + cond);\n                    conflict = bodyWrap.getElementsByTagName(\"conflict\");\n                    if (cond !== null) {\n                        if (cond == \"remote-stream-error\" && conflict.length > 0) {\n                            cond = \"conflict\";\n                        }\n                        this._conn._changeConnectStatus(Strophe.Status.CONNFAIL, cond);\n                    } else {\n                        this._conn._changeConnectStatus(Strophe.Status.CONNFAIL, \"unknown\");\n                    }\n                    this._conn._doDisconnect(cond);\n                    return Strophe.Status.CONNFAIL;\n                }\n\n                // check to make sure we don't overwrite these if _connect_cb is\n                // called multiple times in the case of missing stream:features\n                if (!this.sid) {\n                    this.sid = bodyWrap.getAttribute(\"sid\");\n                }\n                var wind = bodyWrap.getAttribute('requests');\n                if (wind) {\n                    this.window = parseInt(wind, 10);\n                }\n                var hold = bodyWrap.getAttribute('hold');\n                if (hold) {\n                    this.hold = parseInt(hold, 10);\n                }\n                var wait = bodyWrap.getAttribute('wait');\n                if (wait) {\n                    this.wait = parseInt(wait, 10);\n                }\n            },\n\n            /** PrivateFunction: _disconnect\n             *  _Private_ part of Connection.disconnect for Bosh\n             *\n             *  Parameters:\n             *    (Request) pres - This stanza will be sent before disconnecting.\n             */\n            _disconnect: function (pres) {\n                this._sendTerminate(pres);\n            },\n\n            /** PrivateFunction: _doDisconnect\n             *  _Private_ function to disconnect.\n             *\n             *  Resets the SID and RID.\n             */\n            _doDisconnect: function () {\n                this.sid = null;\n                this.rid = Math.floor(Math.random() * 4294967295);\n                if (this._conn._sessionCachingSupported()) {\n                    window.sessionStorage.removeItem('strophe-bosh-session');\n                }\n\n                this._conn.nextValidRid(this.rid);\n            },\n\n            /** PrivateFunction: _emptyQueue\n             * _Private_ function to check if the Request queue is empty.\n             *\n             *  Returns:\n             *    True, if there are no Requests queued, False otherwise.\n             */\n            _emptyQueue: function () {\n                return this._requests.length === 0;\n            },\n\n            /** PrivateFunction: _hitError\n             *  _Private_ function to handle the error count.\n             *\n             *  Requests are resent automatically until their error count reaches\n             *  5.  Each time an error is encountered, this function is called to\n             *  increment the count and disconnect if the count is too high.\n             *\n             *  Parameters:\n             *    (Integer) reqStatus - The request status.\n             */\n            _hitError: function (reqStatus) {\n                this.errors++;\n                Strophe.warn(\"request errored, status: \" + reqStatus +\n                    \", number of errors: \" + this.errors);\n                if (this.errors > 4) {\n                    this._conn._onDisconnectTimeout();\n                }\n            },\n\n            /** PrivateFunction: _no_auth_received\n             *\n             * Called on stream start/restart when no stream:features\n             * has been received and sends a blank poll request.\n             */\n            _no_auth_received: function (_callback) {\n                if (_callback) {\n                    _callback = _callback.bind(this._conn);\n                } else {\n                    _callback = this._conn._connect_cb.bind(this._conn);\n                }\n                var body = this._buildBody();\n                this._requests.push(\n                    new Strophe.Request(body.tree(),\n                        this._onRequestStateChange.bind(\n                            this, _callback.bind(this._conn)),\n                        body.tree().getAttribute(\"rid\")));\n                this._throttledRequestHandler();\n            },\n\n            /** PrivateFunction: _onDisconnectTimeout\n             *  _Private_ timeout handler for handling non-graceful disconnection.\n             *\n             *  Cancels all remaining Requests and clears the queue.\n             */\n            _onDisconnectTimeout: function () {\n                this._abortAllRequests();\n            },\n\n            /** PrivateFunction: _abortAllRequests\n             *  _Private_ helper function that makes sure all pending requests are aborted.\n             */\n            _abortAllRequests: function _abortAllRequests() {\n                var req;\n                while (this._requests.length > 0) {\n                    req = this._requests.pop();\n                    req.abort = true;\n                    req.xhr.abort();\n                    // jslint complains, but this is fine. setting to empty func\n                    // is necessary for IE6\n                    req.xhr.onreadystatechange = function () {\n                    }; // jshint ignore:line\n                }\n            },\n\n            /** PrivateFunction: _onIdle\n             *  _Private_ handler called by Strophe.Connection._onIdle\n             *\n             *  Sends all queued Requests or polls with empty Request if there are none.\n             */\n            _onIdle: function () {\n                var data = this._conn._data;\n\n                // if no requests are in progress, poll\n                if (this._conn.authenticated && this._requests.length === 0 &&\n                    data.length === 0 && !this._conn.disconnecting) {\n                    Strophe.info(\"no requests during idle cycle, sending \" +\n                        \"blank request\");\n                    data.push(null);\n                }\n\n                if (this._conn.paused) {\n                    return;\n                }\n\n                if (this._requests.length < 2 && data.length > 0) {\n                    var body = this._buildBody();\n                    for (var i = 0; i < data.length; i++) {\n                        if (data[i] !== null) {\n                            if (data[i] === \"restart\") {\n                                body.attrs({\n                                    to: this._conn.domain,\n                                    \"xml:lang\": \"en\",\n                                    \"xmpp:restart\": \"true\",\n                                    \"xmlns:xmpp\": Strophe.NS.BOSH\n                                });\n                            } else {\n                                body.cnode(data[i]).up();\n                            }\n                        }\n                    }\n                    delete this._conn._data;\n                    this._conn._data = [];\n                    this._requests.push(\n                        new Strophe.Request(body.tree(),\n                            this._onRequestStateChange.bind(\n                                this, this._conn._dataRecv.bind(this._conn)),\n                            body.tree().getAttribute(\"rid\")));\n                    this._throttledRequestHandler();\n                }\n\n                if (this._requests.length > 0) {\n                    var time_elapsed = this._requests[0].age();\n                    if (this._requests[0].dead !== null) {\n                        if (this._requests[0].timeDead() >\n                            Math.floor(Strophe.SECONDARY_TIMEOUT * this.wait)) {\n                            this._throttledRequestHandler();\n                        }\n                    }\n\n                    if (time_elapsed > Math.floor(Strophe.TIMEOUT * this.wait)) {\n                        Strophe.warn(\"Request \" +\n                            this._requests[0].id +\n                            \" timed out, over \" + Math.floor(Strophe.TIMEOUT * this.wait) +\n                            \" seconds since last activity\");\n                        this._throttledRequestHandler();\n                    }\n                }\n            },\n\n            /** PrivateFunction: _onRequestStateChange\n             *  _Private_ handler for Strophe.Request state changes.\n             *\n             *  This function is called when the XMLHttpRequest readyState changes.\n             *  It contains a lot of error handling logic for the many ways that\n             *  requests can fail, and calls the request callback when requests\n             *  succeed.\n             *\n             *  Parameters:\n             *    (Function) func - The handler for the request.\n             *    (Strophe.Request) req - The request that is changing readyState.\n             */\n            _onRequestStateChange: function (func, req) {\n                Strophe.debug(\"request id \" + req.id +\n                    \".\" + req.sends + \" state changed to \" +\n                    req.xhr.readyState);\n\n                if (req.abort) {\n                    req.abort = false;\n                    return;\n                }\n\n                // request complete\n                var reqStatus;\n                if (req.xhr.readyState == 4) {\n                    reqStatus = 0;\n                    try {\n                        reqStatus = req.xhr.status;\n                    } catch (e) {\n                        // ignore errors from undefined status attribute.  works\n                        // around a browser bug\n                    }\n\n                    if (typeof(reqStatus) == \"undefined\") {\n                        reqStatus = 0;\n                    }\n\n                    if (this.disconnecting) {\n                        if (reqStatus >= 400) {\n                            this._hitError(reqStatus);\n                            return;\n                        }\n                    }\n\n                    var reqIs0 = (this._requests[0] == req);\n                    var reqIs1 = (this._requests[1] == req);\n\n                    if ((reqStatus > 0 && reqStatus < 500) || req.sends > 5) {\n                        // remove from internal queue\n                        this._removeRequest(req);\n                        Strophe.debug(\"request id \" +\n                            req.id +\n                            \" should now be removed\");\n                    }\n\n                    // request succeeded\n                    if (reqStatus == 200) {\n                        // if request 1 finished, or request 0 finished and request\n                        // 1 is over Strophe.SECONDARY_TIMEOUT seconds old, we need to\n                        // restart the other - both will be in the first spot, as the\n                        // completed request has been removed from the queue already\n                        if (reqIs1 ||\n                            (reqIs0 && this._requests.length > 0 &&\n                            this._requests[0].age() > Math.floor(Strophe.SECONDARY_TIMEOUT * this.wait))) {\n                            this._restartRequest(0);\n                        }\n\n                        this._conn.nextValidRid(Number(req.rid) + 1);\n\n                        // call handler\n                        Strophe.debug(\"request id \" +\n                            req.id + \".\" +\n                            req.sends + \" got 200\");\n                        func(req);\n                        this.errors = 0;\n                    } else {\n                        Strophe.error(\"request id \" +\n                            req.id + \".\" +\n                            req.sends + \" error \" + reqStatus +\n                            \" happened\");\n                        if (reqStatus === 0 ||\n                            (reqStatus >= 400 && reqStatus < 600) ||\n                            reqStatus >= 12000) {\n                            this._hitError(reqStatus);\n                            if (reqStatus >= 400 && reqStatus < 500) {\n                                this._conn._changeConnectStatus(Strophe.Status.DISCONNECTING, null);\n                                this._conn._doDisconnect();\n                            }\n                        }\n                    }\n\n                    if (!((reqStatus > 0 && reqStatus < 500) ||\n                        req.sends > 5)) {\n                        this._throttledRequestHandler();\n                    }\n                }\n            },\n\n            /** PrivateFunction: _processRequest\n             *  _Private_ function to process a request in the queue.\n             *\n             *  This function takes requests off the queue and sends them and\n             *  restarts dead requests.\n             *\n             *  Parameters:\n             *    (Integer) i - The index of the request in the queue.\n             */\n            _processRequest: function (i) {\n                var self = this;\n                var req = this._requests[i];\n                var reqStatus = -1;\n\n                try {\n                    if (req.xhr.readyState == 4) {\n                        reqStatus = req.xhr.status;\n                    }\n                } catch (e) {\n                    Strophe.error(\"caught an error in _requests[\" + i +\n                        \"], reqStatus: \" + reqStatus);\n                }\n\n                if (typeof(reqStatus) == \"undefined\") {\n                    reqStatus = -1;\n                }\n\n                // make sure we limit the number of retries\n                if (req.sends > this._conn.maxRetries) {\n                    this._conn._onDisconnectTimeout();\n                    return;\n                }\n\n                var time_elapsed = req.age();\n                var primaryTimeout = (!isNaN(time_elapsed) &&\n                time_elapsed > Math.floor(Strophe.TIMEOUT * this.wait));\n                var secondaryTimeout = (req.dead !== null &&\n                req.timeDead() > Math.floor(Strophe.SECONDARY_TIMEOUT * this.wait));\n                var requestCompletedWithServerError = (req.xhr.readyState == 4 &&\n                (reqStatus < 1 ||\n                reqStatus >= 500));\n                if (primaryTimeout || secondaryTimeout ||\n                    requestCompletedWithServerError) {\n                    if (secondaryTimeout) {\n                        Strophe.error(\"Request \" +\n                            this._requests[i].id +\n                            \" timed out (secondary), restarting\");\n                    }\n                    req.abort = true;\n                    req.xhr.abort();\n                    // setting to null fails on IE6, so set to empty function\n                    req.xhr.onreadystatechange = function () {\n                    };\n                    this._requests[i] = new Strophe.Request(req.xmlData,\n                        req.origFunc,\n                        req.rid,\n                        req.sends);\n                    req = this._requests[i];\n                }\n\n                if (req.xhr.readyState === 0) {\n                    Strophe.debug(\"request id \" + req.id +\n                        \".\" + req.sends + \" posting\");\n\n                    try {\n                        var contentType = this._conn.options.contentType || \"text/xml; charset=utf-8\";\n                        req.xhr.open(\"POST\", this._conn.service, this._conn.options.sync ? false : true);\n                        req.xhr.setRequestHeader && req.xhr.setRequestHeader(\"Content-Type\", contentType);\n                        if (this._conn.options.withCredentials) {\n                            req.xhr.withCredentials = true;\n                        }\n                    } catch (e2) {\n                        Strophe.error(\"XHR open failed.\");\n                        if (!this._conn.connected) {\n                            this._conn._changeConnectStatus(Strophe.Status.CONNFAIL,\n                                \"bad-service\");\n                        }\n                        this._conn.disconnect();\n                        return;\n                    }\n\n                    // Fires the XHR request -- may be invoked immediately\n                    // or on a gradually expanding retry window for reconnects\n                    var self = this\n                    var sendFunc = function () {\n                        req.date = new Date();\n                        if (self._conn.options.customHeaders) {\n                            var headers = self._conn.options.customHeaders;\n                            for (var header in headers) {\n                                if (headers.hasOwnProperty(header)) {\n                                    req.xhr.setRequestHeader(header, headers[header]);\n                                }\n                            }\n                        }\n                        // fix: ie8 req state error\n                        window.XDomainRequest && (req.xhr.readyState = 2)\n                        req.xhr.send(req.data);\n                    };\n\n                    // Implement progressive backoff for reconnects --\n                    // First retry (send == 1) should also be instantaneous\n                    if (req.sends > 1) {\n                        // Using a cube of the retry number creates a nicely\n                        // expanding retry window\n                        var backoff = Math.min(Math.floor(Strophe.TIMEOUT * this.wait),\n                                Math.pow(req.sends, 3)) * 1000;\n\n                        // XXX: setTimeout should be called only with function expressions (23974bc1)\n                        setTimeout(function () {\n                            sendFunc();\n                        }, backoff);\n                    } else {\n                        sendFunc();\n                    }\n\n                    req.sends++;\n\n                    if (this._conn.xmlOutput !== Strophe.Connection.prototype.xmlOutput) {\n                        if (req.xmlData.nodeName === this.strip && req.xmlData.childNodes.length) {\n                            this._conn.xmlOutput(req.xmlData.childNodes[0]);\n                        } else {\n                            this._conn.xmlOutput(req.xmlData);\n                        }\n                    }\n                    if (this._conn.rawOutput !== Strophe.Connection.prototype.rawOutput) {\n                        this._conn.rawOutput(req.data);\n                    }\n                } else {\n                    Strophe.debug(\"_processRequest: \" +\n                        (i === 0 ? \"first\" : \"second\") +\n                        \" request has readyState of \" +\n                        req.xhr.readyState);\n                }\n            },\n\n            /** PrivateFunction: _removeRequest\n             *  _Private_ function to remove a request from the queue.\n             *\n             *  Parameters:\n             *    (Strophe.Request) req - The request to remove.\n             */\n            _removeRequest: function (req) {\n                Strophe.debug(\"removing request\");\n\n                var i;\n                for (i = this._requests.length - 1; i >= 0; i--) {\n                    if (req == this._requests[i]) {\n                        this._requests.splice(i, 1);\n                    }\n                }\n\n                // IE6 fails on setting to null, so set to empty function\n                req.xhr.onreadystatechange = function () {\n                };\n\n                this._throttledRequestHandler();\n            },\n\n            /** PrivateFunction: _restartRequest\n             *  _Private_ function to restart a request that is presumed dead.\n             *\n             *  Parameters:\n             *    (Integer) i - The index of the request in the queue.\n             */\n            _restartRequest: function (i) {\n                var req = this._requests[i];\n                if (req.dead === null) {\n                    req.dead = new Date();\n                }\n\n                this._processRequest(i);\n            },\n\n            /** PrivateFunction: _reqToData\n             * _Private_ function to get a stanza out of a request.\n             *\n             * Tries to extract a stanza out of a Request Object.\n             * When this fails the current connection will be disconnected.\n             *\n             *  Parameters:\n             *    (Object) req - The Request.\n             *\n             *  Returns:\n             *    The stanza that was passed.\n             */\n            _reqToData: function (req) {\n                try {\n                    return req.getResponse();\n                } catch (e) {\n                    if (e != \"parsererror\") {\n                        throw e;\n                    }\n                    this._conn.disconnect(\"strophe-parsererror\");\n                }\n            },\n\n            /** PrivateFunction: _sendTerminate\n             *  _Private_ function to send initial disconnect sequence.\n             *\n             *  This is the first step in a graceful disconnect.  It sends\n             *  the BOSH server a terminate body and includes an unavailable\n             *  presence if authentication has completed.\n             */\n            _sendTerminate: function (pres) {\n                Strophe.info(\"_sendTerminate was called\");\n                var body = this._buildBody().attrs({type: \"terminate\"});\n\n                if (pres) {\n                    body.cnode(pres.tree());\n                }\n\n                var req = new Strophe.Request(body.tree(),\n                    this._onRequestStateChange.bind(\n                        this, this._conn._dataRecv.bind(this._conn)),\n                    body.tree().getAttribute(\"rid\"));\n\n                this._requests.push(req);\n                this._throttledRequestHandler();\n            },\n\n            /** PrivateFunction: _send\n             *  _Private_ part of the Connection.send function for BOSH\n             *\n             * Just triggers the RequestHandler to send the messages that are in the queue\n             */\n            _send: function () {\n                clearTimeout(this._conn._idleTimeout);\n                this._throttledRequestHandler();\n\n                // XXX: setTimeout should be called only with function expressions (23974bc1)\n                this._conn._idleTimeout = setTimeout(function () {\n                    this._onIdle();\n                }.bind(this._conn), 100);\n            },\n\n            /** PrivateFunction: _sendRestart\n             *\n             *  Send an xmpp:restart stanza.\n             */\n            _sendRestart: function () {\n                this._throttledRequestHandler();\n                clearTimeout(this._conn._idleTimeout);\n            },\n\n            /** PrivateFunction: _throttledRequestHandler\n             *  _Private_ function to throttle requests to the connection window.\n             *\n             *  This function makes sure we don't send requests so fast that the\n             *  request ids overflow the connection window in the case that one\n             *  request died.\n             */\n            _throttledRequestHandler: function () {\n                if (!this._requests) {\n                    Strophe.debug(\"_throttledRequestHandler called with \" +\n                        \"undefined requests\");\n                } else {\n                    Strophe.debug(\"_throttledRequestHandler called with \" +\n                        this._requests.length + \" requests\");\n                }\n\n                if (!this._requests || this._requests.length === 0) {\n                    return;\n                }\n\n                if (this._requests.length > 0) {\n                    this._processRequest(0);\n                }\n\n                if (this._requests.length > 1 &&\n                    Math.abs(this._requests[0].rid -\n                        this._requests[1].rid) < this.window) {\n                    this._processRequest(1);\n                }\n            }\n        };\n        return Strophe;\n    }));\n\n    /*\n     This program is distributed under the terms of the MIT license.\n     Please see the LICENSE file for details.\n\n     Copyright 2006-2008, OGG, LLC\n     */\n\n    /* jshint undef: true, unused: true:, noarg: true, latedef: true */\n    /* global define, window, clearTimeout, WebSocket, DOMParser, Strophe, $build */\n\n    (function (root, factory) {\n        if (typeof define === 'function' && define.amd) {\n            define('strophe-websocket', ['strophe-core'], function (core) {\n                return factory(\n                    core.Strophe,\n                    core.$build\n                );\n            });\n        } else {\n            // Browser globals\n            return factory(Strophe, $build);\n        }\n    }(this, function (Strophe, $build) {\n\n        /** Class: Strophe.WebSocket\n         *  _Private_ helper class that handles WebSocket Connections\n         *\n         *  The Strophe.WebSocket class is used internally by Strophe.Connection\n         *  to encapsulate WebSocket sessions. It is not meant to be used from user's code.\n         */\n\n        /** File: websocket.js\n         *  A JavaScript library to enable XMPP over Websocket in Strophejs.\n         *\n         *  This file implements XMPP over WebSockets for Strophejs.\n         *  If a Connection is established with a Websocket url (ws://...)\n         *  Strophe will use WebSockets.\n         *  For more information on XMPP-over-WebSocket see RFC 7395:\n         *  http://tools.ietf.org/html/rfc7395\n         *\n         *  WebSocket support implemented by Andreas Guth (andreas.guth@rwth-aachen.de)\n         */\n\n        /** PrivateConstructor: Strophe.Websocket\n         *  Create and initialize a Strophe.WebSocket object.\n         *  Currently only sets the connection Object.\n         *\n         *  Parameters:\n         *    (Strophe.Connection) connection - The Strophe.Connection that will use WebSockets.\n         *\n         *  Returns:\n         *    A new Strophe.WebSocket object.\n         */\n        Strophe.Websocket = function (connection) {\n            this._conn = connection;\n            this.strip = \"wrapper\";\n\n            var service = connection.service;\n            if (service.indexOf(\"ws:\") !== 0 && service.indexOf(\"wss:\") !== 0) {\n                // If the service is not an absolute URL, assume it is a path and put the absolute\n                // URL together from options, current URL and the path.\n                var new_service = \"\";\n\n                if (connection.options.protocol === \"ws\" && window.location.protocol !== \"https:\") {\n                    new_service += \"ws\";\n                } else {\n                    new_service += \"wss\";\n                }\n\n                new_service += \"://\" + window.location.host;\n\n                if (service.indexOf(\"/\") !== 0) {\n                    new_service += window.location.pathname + service;\n                } else {\n                    new_service += service;\n                }\n\n                connection.service = new_service;\n            }\n        };\n\n        Strophe.Websocket.prototype = {\n            /** PrivateFunction: _buildStream\n             *  _Private_ helper function to generate the <stream> start tag for WebSockets\n             *\n             *  Returns:\n             *    A Strophe.Builder with a <stream> element.\n             */\n            _buildStream: function () {\n                return $build(\"open\", {\n                    \"xmlns\": Strophe.NS.FRAMING,\n                    \"to\": this._conn.domain,\n                    \"version\": '1.0'\n                });\n            },\n\n            /** PrivateFunction: _check_streamerror\n             * _Private_ checks a message for stream:error\n             *\n             *  Parameters:\n             *    (Strophe.Request) bodyWrap - The received stanza.\n             *    connectstatus - The ConnectStatus that will be set on error.\n             *  Returns:\n             *     true if there was a streamerror, false otherwise.\n             */\n            _check_streamerror: function (bodyWrap, connectstatus) {\n                var errors;\n                if (bodyWrap.getElementsByTagNameNS) {\n                    errors = bodyWrap.getElementsByTagNameNS(Strophe.NS.STREAM, \"error\");\n                } else {\n                    errors = bodyWrap.getElementsByTagName(\"stream:error\");\n                }\n                if (errors.length === 0) {\n                    return false;\n                }\n                var error = errors[0];\n\n                var condition = \"\";\n                var text = \"\";\n\n                var ns = \"urn:ietf:params:xml:ns:xmpp-streams\";\n                for (var i = 0; i < error.childNodes.length; i++) {\n                    var e = error.childNodes[i];\n                    if (e.getAttribute(\"xmlns\") !== ns) {\n                        break;\n                    }\n                    if (e.nodeName === \"text\") {\n                        text = e.textContent;\n                    } else {\n                        condition = e.nodeName;\n                    }\n                }\n\n                var errorString = \"WebSocket stream error: \";\n\n                if (condition) {\n                    errorString += condition;\n                } else {\n                    errorString += \"unknown\";\n                }\n\n                if (text) {\n                    errorString += \" - \" + condition;\n                }\n\n                Strophe.error(errorString);\n\n                // close the connection on stream_error\n                this._conn._changeConnectStatus(connectstatus, condition);\n                this._conn._doDisconnect();\n                return true;\n            },\n\n            /** PrivateFunction: _reset\n             *  Reset the connection.\n             *\n             *  This function is called by the reset function of the Strophe Connection.\n             *  Is not needed by WebSockets.\n             */\n            _reset: function () {\n                return;\n            },\n\n            /** PrivateFunction: _connect\n             *  _Private_ function called by Strophe.Connection.connect\n             *\n             *  Creates a WebSocket for a connection and assigns Callbacks to it.\n             *  Does nothing if there already is a WebSocket.\n             */\n            _connect: function () {\n                // Ensure that there is no open WebSocket from a previous Connection.\n                this._closeSocket();\n\n                // Create the new WobSocket\n                this.socket = new WebSocket(this._conn.service, \"xmpp\");\n                this.socket.onopen = this._onOpen.bind(this);\n                this.socket.onerror = this._onError.bind(this);\n                this.socket.onclose = this._onClose.bind(this);\n                this.socket.onmessage = this._connect_cb_wrapper.bind(this);\n            },\n\n            /** PrivateFunction: _connect_cb\n             *  _Private_ function called by Strophe.Connection._connect_cb\n             *\n             * checks for stream:error\n             *\n             *  Parameters:\n             *    (Strophe.Request) bodyWrap - The received stanza.\n             */\n            _connect_cb: function (bodyWrap) {\n                var error = this._check_streamerror(bodyWrap, Strophe.Status.CONNFAIL);\n                if (error) {\n                    return Strophe.Status.CONNFAIL;\n                }\n            },\n\n            /** PrivateFunction: _handleStreamStart\n             * _Private_ function that checks the opening <open /> tag for errors.\n             *\n             * Disconnects if there is an error and returns false, true otherwise.\n             *\n             *  Parameters:\n             *    (Node) message - Stanza containing the <open /> tag.\n             */\n            _handleStreamStart: function (message) {\n                var error = false;\n\n                // Check for errors in the <open /> tag\n                var ns = message.getAttribute(\"xmlns\");\n                if (typeof ns !== \"string\") {\n                    error = \"Missing xmlns in <open />\";\n                } else if (ns !== Strophe.NS.FRAMING) {\n                    error = \"Wrong xmlns in <open />: \" + ns;\n                }\n\n                var ver = message.getAttribute(\"version\");\n                if (typeof ver !== \"string\") {\n                    error = \"Missing version in <open />\";\n                } else if (ver !== \"1.0\") {\n                    error = \"Wrong version in <open />: \" + ver;\n                }\n\n                if (error) {\n                    this._conn._changeConnectStatus(Strophe.Status.CONNFAIL, error);\n                    this._conn._doDisconnect();\n                    return false;\n                }\n\n                return true;\n            },\n\n            /** PrivateFunction: _connect_cb_wrapper\n             * _Private_ function that handles the first connection messages.\n             *\n             * On receiving an opening stream tag this callback replaces itself with the real\n             * message handler. On receiving a stream error the connection is terminated.\n             */\n            _connect_cb_wrapper: function (message) {\n                if (message.data.indexOf(\"<open \") === 0 || message.data.indexOf(\"<?xml\") === 0) {\n\n                    // Strip the XML Declaration, if there is one\n                    var data = message.data.replace(/^(<\\?.*?\\?>\\s*)*/, \"\");\n                    if (data === '') return;\n\n                    var streamStart = new DOMParser().parseFromString(data, \"text/xml\").documentElement;\n                    this._conn.xmlInput(streamStart);\n                    this._conn.rawInput(message.data);\n\n                    //_handleStreamSteart will check for XML errors and disconnect on error\n                    if (this._handleStreamStart(streamStart)) {\n                        //_connect_cb will check for stream:error and disconnect on error\n                        this._connect_cb(streamStart);\n                    }\n                } else if (message.data.indexOf(\"<close \") === 0) { //'<close xmlns=\"urn:ietf:params:xml:ns:xmpp-framing />') {\n                    this._conn.rawInput(message.data);\n                    this._conn.xmlInput(message);\n                    var see_uri = message.getAttribute(\"see-other-uri\");\n                    if (see_uri) {\n                        this._conn._changeConnectStatus(Strophe.Status.REDIRECT, \"Received see-other-uri, resetting connection\");\n                        this._conn.reset();\n                        this._conn.service = see_uri;\n                        this._connect();\n                    } else {\n                        this._conn._changeConnectStatus(Strophe.Status.CONNFAIL, \"Received closing stream\");\n                        this._conn._doDisconnect();\n                    }\n                } else {\n                    var string = this._streamWrap(message.data);\n                    var elem = new DOMParser().parseFromString(string, \"text/xml\").documentElement;\n                    this.socket.onmessage = this._onMessage.bind(this);\n                    this._conn._connect_cb(elem, null, message.data);\n                }\n            },\n\n            /** PrivateFunction: _disconnect\n             *  _Private_ function called by Strophe.Connection.disconnect\n             *\n             *  Disconnects and sends a last stanza if one is given\n             *\n             *  Parameters:\n             *    (Request) pres - This stanza will be sent before disconnecting.\n             */\n            _disconnect: function (pres) {\n                if (this.socket && this.socket.readyState !== WebSocket.CLOSED) {\n                    if (pres) {\n                        this._conn.send(pres);\n                    }\n                    var close = $build(\"close\", {\"xmlns\": Strophe.NS.FRAMING});\n                    this._conn.xmlOutput(close);\n                    var closeString = Strophe.serialize(close);\n                    this._conn.rawOutput(closeString);\n                    try {\n                        this.socket.send(closeString);\n                    } catch (e) {\n                        Strophe.info(\"Couldn't send <close /> tag.\");\n                    }\n                }\n                this._conn._doDisconnect();\n            },\n\n            /** PrivateFunction: _doDisconnect\n             *  _Private_ function to disconnect.\n             *\n             *  Just closes the Socket for WebSockets\n             */\n            _doDisconnect: function () {\n                Strophe.info(\"WebSockets _doDisconnect was called\");\n                this._closeSocket();\n            },\n\n            /** PrivateFunction _streamWrap\n             *  _Private_ helper function to wrap a stanza in a <stream> tag.\n             *  This is used so Strophe can process stanzas from WebSockets like BOSH\n             */\n            _streamWrap: function (stanza) {\n                return \"<wrapper>\" + stanza + '</wrapper>';\n            },\n\n\n            /** PrivateFunction: _closeSocket\n             *  _Private_ function to close the WebSocket.\n             *\n             *  Closes the socket if it is still open and deletes it\n             */\n            _closeSocket: function () {\n                if (this.socket) {\n                    try {\n                        this.socket.close();\n                    } catch (e) {\n                    }\n                }\n                this.socket = null;\n            },\n\n            /** PrivateFunction: _emptyQueue\n             * _Private_ function to check if the message queue is empty.\n             *\n             *  Returns:\n             *    True, because WebSocket messages are send immediately after queueing.\n             */\n            _emptyQueue: function () {\n                return true;\n            },\n\n            /** PrivateFunction: _onClose\n             * _Private_ function to handle websockets closing.\n             *\n             * Nothing to do here for WebSockets\n             */\n            _onClose: function () {\n                if (this._conn.connected && !this._conn.disconnecting) {\n                    Strophe.error(\"Websocket closed unexpectedly\");\n                    this._conn._doDisconnect();\n                } else {\n                    Strophe.info(\"Websocket closed\");\n                }\n            },\n\n            /** PrivateFunction: _no_auth_received\n             *\n             * Called on stream start/restart when no stream:features\n             * has been received.\n             */\n            _no_auth_received: function (_callback) {\n                Strophe.error(\"Server did not send any auth methods\");\n                this._conn._changeConnectStatus(Strophe.Status.CONNFAIL, \"Server did not send any auth methods\");\n                if (_callback) {\n                    _callback = _callback.bind(this._conn);\n                    _callback();\n                }\n                this._conn._doDisconnect();\n            },\n\n            /** PrivateFunction: _onDisconnectTimeout\n             *  _Private_ timeout handler for handling non-graceful disconnection.\n             *\n             *  This does nothing for WebSockets\n             */\n            _onDisconnectTimeout: function () {\n            },\n\n            /** PrivateFunction: _abortAllRequests\n             *  _Private_ helper function that makes sure all pending requests are aborted.\n             */\n            _abortAllRequests: function () {\n            },\n\n            /** PrivateFunction: _onError\n             * _Private_ function to handle websockets errors.\n             *\n             * Parameters:\n             * (Object) error - The websocket error.\n             */\n            _onError: function (error) {\n                Strophe.error(\"Websocket error \" + error);\n                this._conn._changeConnectStatus(Strophe.Status.CONNFAIL, \"The WebSocket connection could not be established or was disconnected.\");\n                this._disconnect();\n            },\n\n            /** PrivateFunction: _onIdle\n             *  _Private_ function called by Strophe.Connection._onIdle\n             *\n             *  sends all queued stanzas\n             */\n            _onIdle: function () {\n                var data = this._conn._data;\n                if (data.length > 0 && !this._conn.paused) {\n                    for (var i = 0; i < data.length; i++) {\n                        if (data[i] !== null) {\n                            var stanza, rawStanza;\n                            if (data[i] === \"restart\") {\n                                stanza = this._buildStream().tree();\n                            } else {\n                                stanza = data[i];\n                            }\n                            rawStanza = Strophe.serialize(stanza);\n                            this._conn.xmlOutput(stanza);\n                            this._conn.rawOutput(rawStanza);\n                            this.socket.send(rawStanza);\n                        }\n                    }\n                    this._conn._data = [];\n                }\n            },\n\n            /** PrivateFunction: _onMessage\n             * _Private_ function to handle websockets messages.\n             *\n             * This function parses each of the messages as if they are full documents.\n             * [TODO : We may actually want to use a SAX Push parser].\n             *\n             * Since all XMPP traffic starts with\n             *  <stream:stream version='1.0'\n             *                 xml:lang='en'\n             *                 xmlns='jabber:client'\n             *                 xmlns:stream='http://etherx.jabber.org/streams'\n             *                 id='3697395463'\n             *                 from='SERVER'>\n             *\n             * The first stanza will always fail to be parsed.\n             *\n             * Additionally, the seconds stanza will always be <stream:features> with\n             * the stream NS defined in the previous stanza, so we need to 'force'\n             * the inclusion of the NS in this stanza.\n             *\n             * Parameters:\n             * (string) message - The websocket message.\n             */\n            _onMessage: function (message) {\n                WebIM && WebIM.config.isDebug && Strophe.info(WebIM.utils.ts() + 'recv:', message.data);\n\n                var elem, data;\n                // check for closing stream\n                var close = '<close xmlns=\"urn:ietf:params:xml:ns:xmpp-framing\" />';\n                if (message.data === close) {\n                    this._conn.rawInput(close);\n                    this._conn.xmlInput(message);\n                    if (!this._conn.disconnecting) {\n                        this._conn._doDisconnect();\n                    }\n                    return;\n                } else if (message.data.search(\"<open \") === 0) {\n                    // This handles stream restarts\n                    elem = new DOMParser().parseFromString(message.data, \"text/xml\").documentElement;\n                    if (!this._handleStreamStart(elem)) {\n                        return;\n                    }\n                } else {\n                    data = this._streamWrap(message.data);\n                    elem = new DOMParser().parseFromString(data, \"text/xml\").documentElement;\n                }\n\n                if (this._check_streamerror(elem, Strophe.Status.ERROR)) {\n                    return;\n                }\n\n                //handle unavailable presence stanza before disconnecting\n                if (this._conn.disconnecting &&\n                    elem.firstChild.nodeName === \"presence\" &&\n                    elem.firstChild.getAttribute(\"type\") === \"unavailable\") {\n                    this._conn.xmlInput(elem);\n                    this._conn.rawInput(Strophe.serialize(elem));\n                    // if we are already disconnecting we will ignore the unavailable stanza and\n                    // wait for the </stream:stream> tag before we close the connection\n                    return;\n                }\n                this._conn._dataRecv(elem, message.data);\n            },\n\n            /** PrivateFunction: _onOpen\n             * _Private_ function to handle websockets connection setup.\n             *\n             * The opening stream tag is sent here.\n             */\n            _onOpen: function () {\n                Strophe.info(\"Websocket open\");\n                var start = this._buildStream();\n                this._conn.xmlOutput(start.tree());\n\n                var startString = Strophe.serialize(start);\n                this._conn.rawOutput(startString);\n                this.socket.send(startString);\n            },\n\n            /** PrivateFunction: _reqToData\n             * _Private_ function to get a stanza out of a request.\n             *\n             * WebSockets don't use requests, so the passed argument is just returned.\n             *\n             *  Parameters:\n             *    (Object) stanza - The stanza.\n             *\n             *  Returns:\n             *    The stanza that was passed.\n             */\n            _reqToData: function (stanza) {\n                return stanza;\n            },\n\n            /** PrivateFunction: _send\n             *  _Private_ part of the Connection.send function for WebSocket\n             *\n             * Just flushes the messages that are in the queue\n             */\n            _send: function () {\n                this._conn.flush();\n            },\n\n            /** PrivateFunction: _sendRestart\n             *\n             *  Send an xmpp:restart stanza.\n             */\n            _sendRestart: function () {\n                clearTimeout(this._conn._idleTimeout);\n                this._conn._onIdle.bind(this._conn)();\n            }\n        };\n        return Strophe;\n    }));\n\n    (function (root) {\n        if (typeof define === 'function' && define.amd) {\n            define(\"strophe\", [\n                \"strophe-core\",\n                \"strophe-bosh\",\n                \"strophe-websocket\"\n            ], function (wrapper) {\n                return wrapper;\n            });\n        }\n    })(this);\n\n    /* jshint ignore:start */\n    if (callback) {\n        if (typeof define === 'function' && define.amd) {\n            //For backwards compatability\n            var n_callback = callback;\n            if (typeof requirejs === 'function') {\n                requirejs([\"strophe\"], function (o) {\n                    n_callback(o.Strophe, o.$build, o.$msg, o.$iq, o.$pres);\n                });\n            } else {\n                require([\"strophe\"], function (o) {\n                    n_callback(o.Strophe, o.$build, o.$msg, o.$iq, o.$pres);\n                });\n            }\n        } else {\n            return callback(Strophe, $build, $msg, $iq, $pres);\n        }\n    }\n\n\n})(function (Strophe, build, msg, iq, pres) {\n    window.Strophe = Strophe;\n    window.$build = build;\n    window.$msg = msg;\n    window.$iq = iq;\n    window.$pres = pres;\n});\n/* jshint ignore:end */\n"]}